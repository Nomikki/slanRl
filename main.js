/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/abilities.ts":
/*!**************************!*\
  !*** ./src/abilities.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Abilities = exports.ABILITIES = void 0;\nvar ABILITIES;\n(function (ABILITIES) {\n    ABILITIES[ABILITIES[\"STR\"] = 0] = \"STR\";\n    ABILITIES[ABILITIES[\"DEX\"] = 1] = \"DEX\";\n    ABILITIES[ABILITIES[\"CON\"] = 2] = \"CON\";\n    ABILITIES[ABILITIES[\"INT\"] = 3] = \"INT\";\n    ABILITIES[ABILITIES[\"WIS\"] = 4] = \"WIS\";\n})(ABILITIES = exports.ABILITIES || (exports.ABILITIES = {}));\nclass Abilities {\n    constructor(str, dex, con, int, wis) {\n        this.str = 0;\n        this.dex = 0;\n        this.con = 0;\n        this.int = 0;\n        this.wis = 0;\n        this.str = str;\n        this.dex = dex;\n        this.con = con;\n        this.int = int;\n        this.wis = wis;\n    }\n    getBonus(type) {\n        let val = 0;\n        switch (type) {\n            case ABILITIES.STR:\n                val = this.str;\n                break;\n            case ABILITIES.DEX:\n                val = this.dex;\n                break;\n            case ABILITIES.CON:\n                val = this.con;\n                break;\n            case ABILITIES.INT:\n                val = this.int;\n                break;\n            case ABILITIES.WIS:\n                val = this.wis;\n                break;\n            default:\n                break;\n        }\n        return Math.floor((val - 10) / 2);\n    }\n    getBonusWithSign(type) {\n        const val = this.getBonus(type);\n        return (val >= 0 ? \"+\" : \"\") + val.toString();\n    }\n}\nexports.Abilities = Abilities;\n\n\n//# sourceURL=webpack://slanrl/./src/abilities.ts?");

/***/ }),

/***/ "./src/actor.ts":
/*!**********************!*\
  !*** ./src/actor.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst ai_1 = __webpack_require__(/*! ./ai */ \"./src/ai.ts\");\nconst pickable_1 = __importStar(__webpack_require__(/*! ./pickable */ \"./src/pickable.ts\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nclass Actor {\n    constructor(x, y, ch, name, color) {\n        this.fovOnly = true;\n        this.blocks = true; //can we walk on this actor?\n        this.x = (0, utils_1.float2int)(x);\n        this.y = (0, utils_1.float2int)(y);\n        this.ch = ch;\n        this.color = color;\n        this.name = name;\n    }\n    create(actorTemplate) {\n        //console.log(actorTemplate);\n        var _a, _b, _c, _d;\n        let fx = undefined;\n        if (((_a = actorTemplate.pickable) === null || _a === void 0 ? void 0 : _a.effectName) === \"AiChangeEffect\") {\n            fx = new pickable_1.AiChangeEffect(new ai_1.ConfusedMonsterAi(parseInt(actorTemplate.pickable.effect.newAi.nbTurns)), actorTemplate.pickable.effect.message);\n        }\n        if (((_b = actorTemplate === null || actorTemplate === void 0 ? void 0 : actorTemplate.pickable) === null || _b === void 0 ? void 0 : _b.effectName) === \"HealthEffect\")\n            fx = new pickable_1.HealthEffect((_c = actorTemplate.pickable) === null || _c === void 0 ? void 0 : _c.effect.amount, undefined);\n        if ((_d = actorTemplate === null || actorTemplate === void 0 ? void 0 : actorTemplate.pickable) === null || _d === void 0 ? void 0 : _d.selectorName) {\n            console.log(actorTemplate.pickable.selectorName);\n            this.pickable = new pickable_1.default(new pickable_1.TargetSelector((0, utils_1.ensure)(actorTemplate.pickable.selector).type, (0, utils_1.ensure)(actorTemplate.pickable.selector).range), fx);\n        }\n        else {\n            this.pickable = new pickable_1.default(undefined, fx);\n        }\n    }\n    render() {\n        var _a, _b;\n        const fovValue = (_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.getMapped(this.x, this.y);\n        if (fovValue === 2 || (fovValue != 0 && !this.fovOnly)) {\n            _1.game.drawChar(this.ch, this.x, this.y, this.color);\n        }\n    }\n    update() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.ai) {\n                yield this.ai.update(this);\n            }\n        });\n    }\n    computeFov() {\n        if (this.fov) {\n            this.fov.compute(this.x, this.y, 10);\n        }\n    }\n    getDistance(x, y) {\n        const dx = this.x - x;\n        const dy = this.y - y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\nexports[\"default\"] = Actor;\n\n\n//# sourceURL=webpack://slanrl/./src/actor.ts?");

/***/ }),

/***/ "./src/ai.ts":
/*!*******************!*\
  !*** ./src/ai.ts ***!
  \*******************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConfusedMonsterAi = exports.TemporaryAI = exports.ConfusedAI = exports.MonsterAI = exports.PlayerAI = exports.random = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst menu_1 = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\nconst random_1 = __importDefault(__webpack_require__(/*! ./random */ \"./src/random.ts\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nexports.random = new random_1.default();\nclass AI {\n}\nexports[\"default\"] = AI;\nclass PlayerAI extends AI {\n    constructor() {\n        super();\n        this.xpLevel = 1;\n    }\n    getNextLevelXP() {\n        const LEVEL_UP_BASE = 200;\n        const LEVEL_UP_FACTOR = 150;\n        return LEVEL_UP_BASE + this.xpLevel * LEVEL_UP_FACTOR;\n    }\n    update(owner) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const levelUpXp = this.getNextLevelXP();\n            if ((0, utils_1.ensure)(owner.destructible).xp >= levelUpXp) {\n                this.xpLevel++;\n                (0, utils_1.ensure)(owner.destructible).xp -= levelUpXp;\n                _1.game.log.add(`Your battle skills grow stronger! You reached level ${this.xpLevel}`, \"#FFFF00\");\n                _1.game.menu = new menu_1.Menu();\n                _1.game.menu.clear();\n                _1.game.menu.addItem(menu_1.MenuItemCode.CONSTITUTION, \"Constitution (+20 hp)\");\n                _1.game.menu.addItem(menu_1.MenuItemCode.STRENGTH, \"Strenght (+1 attack)\");\n                _1.game.menu.addItem(menu_1.MenuItemCode.AGILITY, \"Agility (+1 defense)\");\n                let cursor = 0;\n                let selectedItem = -1;\n                while (true) {\n                    _1.game.clear();\n                    _1.game.renderUI();\n                    _1.game.drawChar(\">\", _1.game.width / 2 - 12, 10 + cursor, \"#FFF\");\n                    for (let i = 0; i < _1.game.menu.items.length; i++) {\n                        _1.game.drawText(_1.game.menu.items[i].label, _1.game.width / 2 - 10, 10 + i);\n                    }\n                    const ch = yield _1.game.getch();\n                    if (ch === \"ArrowDown\")\n                        cursor++;\n                    if (ch === \"ArrowUp\")\n                        cursor--;\n                    if (ch === \"Enter\") {\n                        selectedItem = _1.game.menu.items[cursor].code;\n                        break;\n                    }\n                    cursor = cursor % _1.game.menu.items.length;\n                    if (cursor < 0)\n                        cursor = _1.game.menu.items.length - 1;\n                }\n                if (selectedItem != -1) {\n                    if (selectedItem === menu_1.MenuItemCode.CONSTITUTION) {\n                        (0, utils_1.ensure)(owner.destructible).hp += 20;\n                        (0, utils_1.ensure)(owner.destructible).maxHP += 20;\n                    }\n                    if (selectedItem === menu_1.MenuItemCode.STRENGTH) {\n                        (0, utils_1.ensure)(owner.attacker).power += 1;\n                    }\n                    if (selectedItem === menu_1.MenuItemCode.AGILITY) {\n                        (0, utils_1.ensure)(owner.destructible).defense += 1;\n                    }\n                }\n                _1.game.render();\n            }\n            if (owner.destructible && owner.destructible.isDead())\n                return;\n            let dx = 0;\n            let dy = 0;\n            const ch = yield _1.game.getch();\n            switch (ch) {\n                case \"ArrowLeft\":\n                    dx--;\n                    break;\n                case \"ArrowRight\":\n                    dx++;\n                    break;\n                case \"ArrowUp\":\n                    dy--;\n                    break;\n                case \"ArrowDown\":\n                    dy++;\n                    break;\n                default:\n                    yield this.handleActionKey(owner, ch);\n                    break;\n            }\n            if (dx !== 0 || dy !== 0) {\n                _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                if (this.moveOrAttack(owner, owner.x + dx, owner.y + dy)) {\n                    (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.computeFov();\n                }\n            }\n        });\n    }\n    handleActionKey(owner, ascii) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                _1.game.log.add(\"Which direction?\");\n                _1.game.renderUI();\n                const ch = yield _1.game.getch();\n                console.log(ch);\n                let dx = 0;\n                let dy = 0;\n                if (ch === \"ArrowLeft\") {\n                    dx = -1;\n                }\n                if (ch === \"ArrowRight\") {\n                    dx = 1;\n                }\n                if (ch === \"ArrowUp\") {\n                    dy = -1;\n                }\n                if (ch === \"ArrowDown\") {\n                    dy = 1;\n                }\n                if (!((_a = _1.game === null || _1.game === void 0 ? void 0 : _1.game.map) === null || _a === void 0 ? void 0 : _a.openCloseDoor(owner.x + dx, owner.y + dy))) {\n                    _1.game.log.add(\"There is no any door.\");\n                }\n                (_b = _1.game.player) === null || _b === void 0 ? void 0 : _b.computeFov();\n            });\n            const handleSave = () => __awaiter(this, void 0, void 0, function* () {\n                _1.game.save();\n                _1.game.log.add(\"Game saved...\", \"#0FA\");\n            });\n            const handleNextLevel = () => {\n                var _a, _b;\n                if (((_a = _1.game.stairs) === null || _a === void 0 ? void 0 : _a.x) === owner.x && ((_b = _1.game.stairs) === null || _b === void 0 ? void 0 : _b.y) === owner.y) {\n                    _1.game.nextLevel();\n                }\n                else {\n                    _1.game.log.add(\"There are no stairs here.\");\n                }\n            };\n            const handlePickup = () => {\n                _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                let found = false;\n                for (const actor of _1.game.actors) {\n                    if (actor.pickable && actor.x === owner.x && actor.y === owner.y) {\n                        if (actor.pickable.pick(actor, owner)) {\n                            found = true;\n                            _1.game.log.add(`You pick up the ${actor.name}`, \"#AAA\");\n                            break;\n                        }\n                        else if (!found) {\n                            found = true;\n                            _1.game.log.add(\"Your inventory is full.\", \"#F00\");\n                        }\n                    }\n                }\n                if (!found) {\n                    _1.game.log.add(\"There's nothing here that you can pick up.\");\n                }\n            };\n            const handleUseItem = () => __awaiter(this, void 0, void 0, function* () {\n                _1.game.log.add(\"Use item\");\n                const useItem = yield this.choseFromInventory(owner);\n                if (useItem) {\n                    yield (0, utils_1.ensure)(useItem.pickable).use(useItem, owner);\n                    _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                }\n                else {\n                    _1.game.log.add(\"Nevermind...\");\n                }\n            });\n            const handleDropItem = () => __awaiter(this, void 0, void 0, function* () {\n                const dropItem = yield this.choseFromInventory(owner);\n                if (dropItem) {\n                    yield (0, utils_1.ensure)(dropItem.pickable).drop(dropItem, owner);\n                    _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                }\n                else {\n                    _1.game.log.add(\"Nevermind...\");\n                }\n            });\n            switch (ascii) {\n                case \"S\": //save\n                    handleSave();\n                    break;\n                case \">\": //go down\n                    handleNextLevel();\n                    break;\n                case \"g\": //pickup item\n                    handlePickup();\n                    break;\n                case \"i\": //use item\n                    yield handleUseItem();\n                    break;\n                case \"d\": //drop item\n                    yield handleDropItem();\n                    break;\n                case \"o\": //open\n                    yield handleOpen();\n                    break;\n                default:\n                    break;\n            }\n        });\n    }\n    moveOrAttack(owner, targetX, targetY) {\n        var _a;\n        if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.isWall(targetX, targetY))\n            return false; //move\n        for (const actor of _1.game.actors) {\n            if (actor.destructible &&\n                !actor.destructible.isDead() &&\n                actor.x === targetX &&\n                actor.y === targetY) {\n                if (actor.name === \"door\") {\n                    if (actor.blocks)\n                        _1.game.log.add(\"There is a door!\");\n                    else\n                        break;\n                }\n                else {\n                    (0, utils_1.ensure)(owner.attacker).attack(owner, actor);\n                }\n                return false; //attack\n            }\n        }\n        //look for corpses or items\n        for (const actor of _1.game.actors) {\n            const corpseOrItem = (actor.destructible && actor.destructible.isDead) || actor.pickable;\n            if (corpseOrItem && actor.x === targetX && actor.y === targetY) {\n                _1.game.log.add(`There is a ${actor.name} here`);\n            }\n        }\n        owner.x = targetX;\n        owner.y = targetY;\n        return true;\n    }\n    choseFromInventory(owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            _1.game.clear();\n            _1.game.render();\n            for (let y = 0; y < 28; y++) {\n                for (let x = 0; x < 40; x++) {\n                    if ((y === 0 || y === 27) && x > 0 && x < 39)\n                        _1.game.drawChar(\"-\", x + 20, y, \"#AAA\");\n                    else if ((x === 0 || x === 39) && y > 0 && y < 27)\n                        _1.game.drawChar(\"|\", x + 20, y, \"#AAA\");\n                    else if (y === 0 || x === 0 || y === 27 || x === 39)\n                        _1.game.drawChar(\"+\", x + 20, y, \"#AAA\");\n                    else\n                        _1.game.drawChar(\" \", x + 20, y);\n                }\n            }\n            _1.game.drawText(\" INVENTORY \", 34, 0);\n            //game.renderUI();\n            let shortcut = \"a\";\n            let i = 0;\n            for (const it of (0, utils_1.ensure)(owner.container).inventory) {\n                _1.game.drawText(shortcut + \") \" + it.name, 22, 2 + i);\n                shortcut = String.fromCharCode(shortcut.charCodeAt(0) + 1);\n                i++;\n            }\n            const ch = yield _1.game.getch();\n            const actorIndex = ch.charCodeAt(0) - 97; //97 = a\n            if (actorIndex >= 0 &&\n                actorIndex < (0, utils_1.ensure)(owner.container).inventory.length) {\n                return (0, utils_1.ensure)(owner.container).inventory[actorIndex];\n            }\n            return null;\n        });\n    }\n}\nexports.PlayerAI = PlayerAI;\nclass MonsterAI extends AI {\n    constructor() {\n        super();\n        this.TRACKING_TURNS = 3;\n        this.moveCount = 0;\n    }\n    update(owner) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const player = _1.game.player;\n            if ((owner.destructible && owner.destructible.isDead()) || !player)\n                return;\n            if ((_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.isInFov(owner.x, owner.y)) {\n                this.moveCount = this.TRACKING_TURNS;\n            }\n            else {\n                this.moveCount--;\n            }\n            if (this.moveCount > 0) {\n                this.moveOrAttack(owner, player.x, player.y);\n            }\n        });\n    }\n    moveOrAttack(owner, targetX, targetY) {\n        var _a, _b, _c, _d;\n        let dx = targetX - owner.x;\n        let dy = targetY - owner.y;\n        const stepdx = dx > 0 ? 1 : -1;\n        const stepdy = dy > 0 ? 1 : -1;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance >= 2) {\n            dx = Math.round(dx / distance);\n            dy = Math.round(dy / distance);\n            if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk(owner.x + dx, owner.y + dy)) {\n                owner.x += (0, utils_1.float2int)(dx);\n                owner.y += (0, utils_1.float2int)(dy);\n            }\n            else if ((_b = _1.game.map) === null || _b === void 0 ? void 0 : _b.canWalk(owner.x + stepdx, owner.y)) {\n                owner.x += (0, utils_1.float2int)(stepdx);\n            }\n            else if ((_c = _1.game.map) === null || _c === void 0 ? void 0 : _c.canWalk(owner.x, owner.y + stepdy)) {\n                owner.y += (0, utils_1.float2int)(stepdy);\n            }\n        }\n        else {\n            (_d = owner === null || owner === void 0 ? void 0 : owner.attacker) === null || _d === void 0 ? void 0 : _d.attack(owner, (0, utils_1.ensure)(_1.game.player));\n        }\n    }\n}\nexports.MonsterAI = MonsterAI;\nclass ConfusedAI extends AI {\n    constructor(nbTurns, oldAi) {\n        super();\n        this.nbTurns = nbTurns;\n        this.oldAi = oldAi;\n    }\n    update(owner) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const dx = exports.random.getInt(-1, 1);\n            const dy = exports.random.getInt(-1, 1);\n            if (dx !== 0 || dy !== 0) {\n                const destx = owner.x + dx;\n                const desty = owner.y + dy;\n                if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk(destx, desty)) {\n                    owner.x = destx;\n                    owner.y = desty;\n                }\n                else {\n                    const actor = _1.game.getActor(destx, desty);\n                    if (actor) {\n                        (_b = owner === null || owner === void 0 ? void 0 : owner.attacker) === null || _b === void 0 ? void 0 : _b.attack(owner, actor);\n                    }\n                }\n            }\n            this.nbTurns--;\n            if (this.nbTurns <= 0) {\n                owner.ai = this.oldAi;\n            }\n        });\n    }\n}\nexports.ConfusedAI = ConfusedAI;\nclass TemporaryAI extends AI {\n    constructor(nbTurns) {\n        super();\n        this.nbTurns = nbTurns;\n    }\n    update(owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.nbTurns--;\n            if (this.nbTurns === 0) {\n                owner.ai = this.oldAi;\n            }\n        });\n    }\n    applyTo(actor) {\n        this.oldAi = actor.ai;\n        actor.ai = this;\n    }\n}\nexports.TemporaryAI = TemporaryAI;\nclass ConfusedMonsterAi extends TemporaryAI {\n    constructor(nbTurns) {\n        super(nbTurns);\n    }\n    update(owner) {\n        const _super = Object.create(null, {\n            update: { get: () => super.update }\n        });\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const dx = exports.random.getInt(-1, 1);\n            const dy = exports.random.getInt(-1, 1);\n            if (dx != 0 || dy != 0) {\n                const destx = owner.x + dx;\n                const desty = owner.y + dy;\n                if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk(destx, desty)) {\n                    owner.x = destx;\n                    owner.y = desty;\n                }\n                else {\n                    const actor = _1.game.getActor(destx, desty);\n                    if (actor) {\n                        (_b = owner === null || owner === void 0 ? void 0 : owner.attacker) === null || _b === void 0 ? void 0 : _b.attack(owner, actor);\n                    }\n                }\n            }\n            _super.update.call(this, owner);\n        });\n    }\n}\nexports.ConfusedMonsterAi = ConfusedMonsterAi;\n\n\n//# sourceURL=webpack://slanrl/./src/ai.ts?");

/***/ }),

/***/ "./src/attacker.ts":
/*!*************************!*\
  !*** ./src/attacker.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nclass Attacker {\n    constructor(power) {\n        this.power = power;\n    }\n    attack(owner, target) {\n        if (target.destructible && !target.destructible.isDead()) {\n            if (this.power - target.destructible.defense > 0) {\n                const dmg = this.power - target.destructible.defense;\n                _1.game.log.add(`${owner.name} attacks ${target.name} for ${dmg} hit points.`, owner === _1.game.player ? \"#DDD\" : \"#AAA\");\n            }\n            else {\n                _1.game.log.add(`${owner.name} attacks ${target.name} but it has no effect!`);\n            }\n            target.destructible.takeDamage(target, this.power);\n        }\n        else {\n            _1.game.log.add(`${owner.name} attacks ${target.name} in vain.`);\n        }\n    }\n}\nexports[\"default\"] = Attacker;\n\n\n//# sourceURL=webpack://slanrl/./src/attacker.ts?");

/***/ }),

/***/ "./src/bsp_generator.ts":
/*!******************************!*\
  !*** ./src/bsp_generator.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst bsp_node_1 = __importDefault(__webpack_require__(/*! ./bsp_node */ \"./src/bsp_node.ts\"));\nconst random_1 = __importDefault(__webpack_require__(/*! ./random */ \"./src/random.ts\"));\nconst rectangle_1 = __importDefault(__webpack_require__(/*! ./rectangle */ \"./src/rectangle.ts\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nconst random = new random_1.default();\nclass bspGenerator {\n    constructor(x, y, w, h, maxLevel = 5) {\n        this.doorPlaces = null;\n        this.tempRooms = null;\n        this.maxLevel = maxLevel;\n        this.rootContainer = new rectangle_1.default(x + 1, y + 1, w - 2, h - 2);\n        this.rows = h;\n        this.cols = w;\n        this.map = [];\n        this.doorPlaces = [];\n        this.tempRooms = [];\n        for (let h = 0; h < this.rows; h++) {\n            for (let w = 0; w < this.cols; w++) {\n                const index = this.cols * h + w;\n                this.map[index] = 1;\n            }\n        }\n        this.tree = this.Devide(this.rootContainer, 0);\n        this.rooms = this.tree.GetLeafs();\n        this.CreateRooms();\n        this.ConnectRooms(this.tree);\n    }\n    RandomSplit(container) {\n        let r1, r2;\n        let splitVertical = random.getInt(0, 1) ? false : true;\n        if (container.w > container.h && container.w / container.h >= 0.05) {\n            splitVertical = true;\n        }\n        else {\n            splitVertical = false;\n        }\n        if (splitVertical) {\n            //Vertical\n            const w = random.getInt(container.w * 0.3, container.w * 0.6);\n            r1 = new rectangle_1.default(container.x, container.y, w, container.h);\n            r2 = new rectangle_1.default(container.x + w, container.y, container.w - w, container.h);\n        }\n        else {\n            //horizontal\n            const h = random.getInt(container.h * 0.3, container.h * 0.6);\n            r1 = new rectangle_1.default(container.x, container.y, container.w, h);\n            r2 = new rectangle_1.default(container.x, container.y + h, container.w, container.h - h);\n        }\n        return [r1, r2];\n    }\n    Devide(container, level) {\n        const root = new bsp_node_1.default(container);\n        if (level < this.maxLevel) {\n            const sr = this.RandomSplit(container);\n            root.A = this.Devide(sr[0], level + 1);\n            root.B = this.Devide(sr[1], level + 1);\n        }\n        return root;\n    }\n    CreateRooms() {\n        //for (let i = 0; i < this.rooms.length; i++) {\n        for (const room of this.rooms) {\n            const w = random.getInt(room.w * 0.5, room.w * 0.9);\n            const h = random.getInt(room.h * 0.5, room.h * 0.9);\n            const x = random.getInt(room.x, room.x + room.w - w);\n            const y = random.getInt(room.y, room.y + room.h - h);\n            const rect = new rectangle_1.default(x, y, x + w, y + h);\n            this.tempRooms.push(rect);\n            for (let hi = y; hi < y + h; hi++) {\n                for (let wi = x; wi < x + w; wi++) {\n                    const index = this.cols * hi + wi;\n                    this.map[index] = 0;\n                }\n            }\n        }\n    }\n    IsThereRoom(x, y) {\n        for (const room of this.tempRooms) {\n            if (x >= room.x && y >= room.y && x <= room.w && y <= room.h) {\n                return true;\n            }\n        }\n        return false;\n    }\n    ConnectRooms(node) {\n        if (node.A === null || node.B === null)\n            return;\n        const x1 = (0, utils_1.float2int)(node.A.leaf.GetCenterX());\n        const y1 = (0, utils_1.float2int)(node.A.leaf.GetCenterY());\n        const x2 = (0, utils_1.float2int)(node.B.leaf.GetCenterX());\n        const y2 = (0, utils_1.float2int)(node.B.leaf.GetCenterY());\n        let doorsCreated = false;\n        let lastWasInRoom = false;\n        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {\n            const index = this.cols * Math.max(y1, y2) + x;\n            this.map[index] = 0;\n            if (!doorsCreated && this.IsThereRoom(x, Math.max(y1, y2)) === true) {\n                lastWasInRoom = true;\n            }\n            else if (!doorsCreated &&\n                this.IsThereRoom(x, Math.max(y1, y2)) === false) {\n                if (lastWasInRoom === true) {\n                    doorsCreated = true;\n                    const re = new rectangle_1.default(x, Math.max(y1, y2), 0, 0);\n                    this.doorPlaces.push(re);\n                }\n            }\n        }\n        doorsCreated = false;\n        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {\n            const index = this.cols * y + Math.max(x1, x2);\n            this.map[index] = 0;\n            if (!doorsCreated && this.IsThereRoom(Math.max(x1, x2), y) === true) {\n                lastWasInRoom = true;\n            }\n            else if (!doorsCreated &&\n                this.IsThereRoom(Math.max(x1, x2), y) === false) {\n                if (lastWasInRoom === true) {\n                    doorsCreated = true;\n                    const re = new rectangle_1.default(Math.max(x1, x2), y, 0, 0);\n                    this.doorPlaces.push(re);\n                }\n            }\n        }\n        this.ConnectRooms(node.A);\n        this.ConnectRooms(node.B);\n    }\n}\nexports[\"default\"] = bspGenerator;\n\n\n//# sourceURL=webpack://slanrl/./src/bsp_generator.ts?");

/***/ }),

/***/ "./src/bsp_node.ts":
/*!*************************!*\
  !*** ./src/bsp_node.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst rectangle_1 = __importDefault(__webpack_require__(/*! ./rectangle */ \"./src/rectangle.ts\"));\nclass bspNode extends rectangle_1.default {\n    constructor(leaf) {\n        super(leaf.x, leaf.y, leaf.w, leaf.h);\n        this.A = null;\n        this.B = null;\n        this.leaf = leaf;\n    }\n    GetLeafs() {\n        if (this.A === null && this.B === null) {\n            return [this.leaf];\n        }\n        else {\n            return [].concat(this.A.GetLeafs(), this.B.GetLeafs());\n        }\n    }\n}\nexports[\"default\"] = bspNode;\n\n\n//# sourceURL=webpack://slanrl/./src/bsp_node.ts?");

/***/ }),

/***/ "./src/container.ts":
/*!**************************!*\
  !*** ./src/container.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Container {\n    constructor(size) {\n        this.size = size; //maximum number of actors\n        this.inventory = [];\n    }\n    add(actor) {\n        if (this.size > 0 && this.inventory.length >= this.size) {\n            //inventory is full\n            return false;\n        }\n        else {\n            this.inventory.push(actor);\n            return true;\n        }\n    }\n    remove(actor) {\n        for (let i = 0; i < this.inventory.length; i++) {\n            if (this.inventory[i] === actor) {\n                this.inventory.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\nexports[\"default\"] = Container;\n\n\n//# sourceURL=webpack://slanrl/./src/container.ts?");

/***/ }),

/***/ "./src/destructible.ts":
/*!*****************************!*\
  !*** ./src/destructible.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PlayerDestructible = exports.MonsterDestructible = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nclass Destructible {\n    constructor(maxHP, defense, corpseName, type, xp) {\n        this.maxHP = maxHP;\n        this.hp = this.maxHP;\n        this.defense = defense;\n        this.corpseName = corpseName;\n        this.type = type;\n        this.xp = xp;\n    }\n    isDead() {\n        return this.hp <= 0;\n    }\n    heal(amount) {\n        this.hp += amount;\n        if (this.hp > this.maxHP) {\n            amount -= this.hp - this.maxHP;\n            this.hp = this.maxHP;\n        }\n        return amount;\n    }\n    takeDamage(owner, damage) {\n        damage -= this.defense;\n        if (damage > 0) {\n            this.hp -= damage;\n            if (this.hp <= 0) {\n                this.die(owner);\n            }\n        }\n        else {\n            damage = 0;\n        }\n        return damage;\n    }\n    die(owner) {\n        owner.ch = \"%\";\n        owner.color = \"#AA0000\";\n        owner.name = this.corpseName;\n        owner.blocks = false;\n        _1.game.sendToBack(owner);\n    }\n}\nexports[\"default\"] = Destructible;\nclass MonsterDestructible extends Destructible {\n    constructor(maxHP, defense, corpseName, xp) {\n        super(maxHP, defense, corpseName, \"monster\", xp);\n        this.xp = xp;\n    }\n    die(owner) {\n        var _a;\n        _1.game.log.add(`${owner.name} is dead. You gain ${this.xp} xp`);\n        (0, utils_1.ensure)((_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.destructible).xp += this.xp;\n        super.die(owner);\n    }\n}\nexports.MonsterDestructible = MonsterDestructible;\nclass PlayerDestructible extends Destructible {\n    constructor(maxHP, defense, corpseName) {\n        super(maxHP, defense, corpseName, \"player\", 0);\n    }\n    die(owner) {\n        _1.game.log.add(\"You died\", \"#A00\");\n        super.die(owner);\n        _1.game.gameStatus = _1.GameStatus.DEFEAT;\n    }\n}\nexports.PlayerDestructible = PlayerDestructible;\n\n\n//# sourceURL=webpack://slanrl/./src/destructible.ts?");

/***/ }),

/***/ "./src/fov.ts":
/*!********************!*\
  !*** ./src/fov.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nclass Fov {\n    constructor(w, h) {\n        this.width = w;\n        this.height = h;\n        this.mapped = new Array(this.width * this.height).fill(0);\n    }\n    clear() {\n        for (let i = 0; i < this.width * this.height; i++) {\n            if (this.mapped[i] === 2) {\n                this.mapped[i] = 1;\n            }\n        }\n    }\n    fullClear() {\n        this.mapped = new Array(this.width * this.height).fill(0);\n    }\n    showAll() {\n        this.mapped = new Array(this.width * this.height).fill(1);\n    }\n    /* Just a placeholder */\n    compute(x, y, len) {\n        var _a;\n        this.clear();\n        let dx = 0;\n        let dy = 0;\n        let px = 0;\n        let py = 0;\n        this.mapped[x + y * this.width] = 2;\n        for (let a = 0; a < 360; a++) {\n            dx = Math.sin((a / 3.1415) * 180.0);\n            dy = Math.cos((a / 3.1415) * 180.0);\n            px = x + 0.5;\n            py = y + 0.5;\n            for (let l = 0; l < len; l++) {\n                px += dx;\n                py += dy;\n                if (px <= 0 || px >= this.width || py <= 0 || py >= this.height) {\n                    break;\n                }\n                const id = (0, utils_1.float2int)(px) + (0, utils_1.float2int)(py) * this.width;\n                this.mapped[id] = 2;\n                if (!((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk((0, utils_1.float2int)(px), (0, utils_1.float2int)(py)))) {\n                    break;\n                }\n            }\n        }\n    }\n    getMapped(x, y) {\n        if (x >= 0 && y >= 0 && x < this.width && y < this.height)\n            return this.mapped[x + y * this.width];\n        else\n            return 2;\n    }\n    isInFov(x, y) {\n        if (x >= 0 && y >= 0 && x < this.width && y < this.height) {\n            return this.mapped[x + y * this.width] > 0;\n        }\n        return false;\n    }\n}\nexports[\"default\"] = Fov;\n\n\n//# sourceURL=webpack://slanrl/./src/fov.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.game = exports.GameStatus = void 0;\nconst abilities_1 = __webpack_require__(/*! ./abilities */ \"./src/abilities.ts\");\nconst actor_1 = __importDefault(__webpack_require__(/*! ./actor */ \"./src/actor.ts\"));\nconst ai_1 = __webpack_require__(/*! ./ai */ \"./src/ai.ts\");\nconst attacker_1 = __importDefault(__webpack_require__(/*! ./attacker */ \"./src/attacker.ts\"));\nconst container_1 = __importDefault(__webpack_require__(/*! ./container */ \"./src/container.ts\"));\nconst destructible_1 = __importStar(__webpack_require__(/*! ./destructible */ \"./src/destructible.ts\"));\nconst fov_1 = __importDefault(__webpack_require__(/*! ./fov */ \"./src/fov.ts\"));\nconst log_1 = __importDefault(__webpack_require__(/*! ./log */ \"./src/log.ts\"));\nconst map_1 = __importDefault(__webpack_require__(/*! ./map */ \"./src/map.ts\"));\nconst menu_1 = __webpack_require__(/*! ./menu */ \"./src/menu.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar GameStatus;\n(function (GameStatus) {\n    GameStatus[GameStatus[\"STARTUP\"] = 0] = \"STARTUP\";\n    GameStatus[GameStatus[\"IDLE\"] = 1] = \"IDLE\";\n    GameStatus[GameStatus[\"NEW_TURN\"] = 2] = \"NEW_TURN\";\n    GameStatus[GameStatus[\"VICTORY\"] = 3] = \"VICTORY\";\n    GameStatus[GameStatus[\"DEFEAT\"] = 4] = \"DEFEAT\";\n})(GameStatus = exports.GameStatus || (exports.GameStatus = {}));\nclass Game {\n    constructor() {\n        this.gameStatus = GameStatus.STARTUP;\n        this.masterSeed = 0;\n        this.canvas = document.getElementById(\"screen\");\n        this.ctx = this.canvas.getContext(\"2d\");\n        this.ctx.font = \"12px Arial\";\n        this.fontSize = 12;\n        this.ctx.textAlign = \"center\";\n        this.log = new log_1.default();\n        this.lastKey = \"\";\n        this.depth = 0;\n        this.width = 80;\n        this.height = 40;\n        this.actors = [];\n        this.map = new map_1.default(this.width, this.height);\n    }\n    term() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log = new log_1.default();\n            this.actors = [];\n            this.map = new map_1.default(this.width, this.height);\n            this.player = undefined;\n        });\n    }\n    init(withActors, createPlayer = true) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, utils_1.ensure)(this.map).generate(withActors, this.masterSeed, this.depth);\n            if (withActors) {\n                let i = 0;\n                if (createPlayer) {\n                    i = this.actors.push(new actor_1.default(2, 2, \"@\", \"hero\", \"#CCC\")) - 1;\n                    this.player = this.actors[i];\n                    this.player.destructible = new destructible_1.PlayerDestructible(30, 2, \"your cadaver\");\n                    this.player.attacker = new attacker_1.default(5);\n                    this.player.ai = new ai_1.PlayerAI();\n                    this.player.abilities = new abilities_1.Abilities(18, 15, 10, 8, 12);\n                    this.player.container = new container_1.default(26);\n                    this.player.fov = new fov_1.default(this.width, this.height);\n                }\n                (0, utils_1.ensure)(this.player).x = (0, utils_1.ensure)(this.map).startX;\n                (0, utils_1.ensure)(this.player).y = (0, utils_1.ensure)(this.map).startY;\n                (_a = (0, utils_1.ensure)(this.player).fov) === null || _a === void 0 ? void 0 : _a.fullClear();\n                i = this.actors.push(new actor_1.default(0, 0, \">\", \"stairs\", \"#FFF\")) - 1;\n                this.stairs = this.actors[i];\n                this.stairs.blocks = false;\n                this.stairs.fovOnly = false;\n                this.stairs.x = (0, utils_1.ensure)(this.map).stairsX;\n                this.stairs.y = (0, utils_1.ensure)(this.map).stairsY;\n                this.log.add(\"Welcome stranger!\", \"#FFF\");\n            }\n            else {\n                this.log.add(\"Welcome back stranger!\", \"#FFF\");\n            }\n            this.gameStatus = GameStatus.STARTUP;\n        });\n    }\n    nextLevel() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.depth++;\n            this.log.add(\"You take steps down.\");\n            this.map = undefined;\n            this.stairs = undefined;\n            const tempPlayer = this.player;\n            this.actors = Array();\n            this.map = new map_1.default(this.width, this.height);\n            this.init(true, false);\n            this.actors.push(tempPlayer);\n            this.save();\n        });\n    }\n    newGame() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.masterSeed = (0, utils_1.float2int)(Math.random() * 0x7ffffff);\n            this.depth = 1;\n            yield this.term();\n            yield this.init(true, true);\n            yield this.save();\n        });\n    }\n    continueGame() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (window.localStorage.getItem(\"seed\") !== null) {\n                const savedVersion = window.localStorage.getItem(\"version\");\n                if (savedVersion === null)\n                    window.localStorage.setItem(\"version\", \"v0.0.1.8a\");\n                this.masterSeed = parseInt(window.localStorage.getItem(\"seed\"));\n                this.depth = parseInt(window.localStorage.getItem(\"depth\"));\n                yield this.init(false);\n                const tempUsers = JSON.parse(window.localStorage.getItem(\"actors\") || \"[]\");\n                for (const actor of tempUsers) {\n                    const i = this.actors.push(new actor_1.default(actor.x, actor.y, actor.ch, actor.name, actor.color)) - 1;\n                    //this.actors[i].ai = undefined;\n                    if (actor.fov) {\n                        this.actors[i].fov = new fov_1.default(this.width, this.height);\n                        (0, utils_1.ensure)(this.actors[i].fov).mapped = actor.fov.mapped;\n                    }\n                    if (actor.container) {\n                        this.actors[i].container = yield new container_1.default(26);\n                        for (const it of actor.container.inventory) {\n                            const k = (0, utils_1.ensure)(this.actors[i].container).inventory.push(new actor_1.default(it.x, it.y, it.ch, it.name, it.color)) - 1;\n                            (0, utils_1.ensure)(this.actors[i].container).inventory[k].create(it);\n                        }\n                    }\n                    if (actor.attacker) {\n                        this.actors[i].attacker = new attacker_1.default(actor.attacker.power);\n                    }\n                    if (actor.pickable) {\n                        this.actors[i].create(actor);\n                    }\n                    if (actor.name === \"stairs\") {\n                        this.stairs = this.actors[i];\n                    }\n                    if (actor.name === \"door\") {\n                        this.actors[i].destructible = new destructible_1.default(100, 0, \"broken door\", \"door\", 0);\n                        this.actors[i].blocks = actor.blocks;\n                    }\n                    if (actor.destructible) {\n                        if (actor.destructible.type === \"player\") {\n                            this.player = this.actors[i];\n                            this.actors[i].destructible = new destructible_1.PlayerDestructible(30, 2, \"player corpse\");\n                            this.actors[i].ai = new ai_1.PlayerAI();\n                            (0, utils_1.ensure)(this.actors[i].destructible).xp = actor.destructible.xp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).hp = actor.destructible.hp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).maxHP =\n                                actor.destructible.maxHP;\n                            (0, utils_1.ensure)(this.actors[i].destructible).defense =\n                                actor.destructible.defense;\n                            (0, utils_1.ensure)(this.actors[i].destructible).corpseName =\n                                actor.destructible.corpseName;\n                        }\n                        if (actor.destructible.type === \"monster\") {\n                            this.actors[i].destructible = new destructible_1.MonsterDestructible(1, 1, \"monster corpse\", 0);\n                            (0, utils_1.ensure)(this.actors[i].destructible).xp = actor.destructible.xp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).hp = actor.destructible.hp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).maxHP =\n                                actor.destructible.maxHP;\n                            (0, utils_1.ensure)(this.actors[i].destructible).defense =\n                                actor.destructible.defense;\n                            (0, utils_1.ensure)(this.actors[i].destructible).corpseName =\n                                actor.destructible.corpseName;\n                            this.actors[i].ai = new ai_1.MonsterAI();\n                        }\n                    }\n                }\n            }\n        });\n    }\n    load() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (window.localStorage.getItem(\"version\") !== \"v0.0.1.8a\")\n                window.localStorage.clear();\n            this.menu = new menu_1.Menu();\n            this.menu.clear();\n            if (window.localStorage.getItem(\"depth\"))\n                this.menu.addItem(menu_1.MenuItemCode.CONTINUE, \"Continue\");\n            this.menu.addItem(menu_1.MenuItemCode.NEW_GAME, \"New Game\");\n            let cursor = 0;\n            let selectedItem = -1;\n            while (true) {\n                this.clear();\n                this.drawChar(\">\", this.width / 2 - 12, 10 + cursor, \"#FFF\");\n                for (let i = 0; i < this.menu.items.length; i++) {\n                    this.drawText(this.menu.items[i].label, this.width / 2 - 10, 10 + i);\n                }\n                const ch = yield this.getch();\n                if (ch === \"ArrowDown\")\n                    cursor++;\n                if (ch === \"ArrowUp\")\n                    cursor--;\n                if (ch === \"Enter\") {\n                    selectedItem = this.menu.items[cursor].code;\n                    break;\n                }\n                cursor = cursor % this.menu.items.length;\n                if (cursor < 0)\n                    cursor = this.menu.items.length - 1;\n            }\n            if (selectedItem != -1) {\n                if (selectedItem === menu_1.MenuItemCode.NEW_GAME) {\n                    yield this.newGame();\n                }\n                if (selectedItem === menu_1.MenuItemCode.CONTINUE) {\n                    yield this.continueGame();\n                }\n            }\n        });\n    }\n    save() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pl = (0, utils_1.ensure)(this.player);\n            if ((0, utils_1.ensure)(pl.destructible).isDead()) {\n                window.localStorage.clear();\n            }\n            else {\n                (0, utils_1.ensure)(this.map).save();\n                window.localStorage.setItem(\"playerID\", this.actors.indexOf(pl).toString());\n                window.localStorage.setItem(\"actors\", JSON.stringify(this.actors));\n                window.localStorage.setItem(\"version\", \"v0.0.1.8a\");\n            }\n        });\n    }\n    clear(color = \"#000\") {\n        //Game\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(0, 0, this.width * this.fontSize, this.height * this.fontSize);\n        //\"UI\"\n        this.ctx.fillRect(0, this.height * this.fontSize, this.width * this.fontSize, this.canvas.height - this.height * this.fontSize);\n    }\n    drawChar(ch, x, y, color = \"#000\") {\n        this.ctx.textAlign = \"center\";\n        this.ctx.fillStyle = \"#040414\";\n        this.ctx.fillRect(x * this.fontSize - this.fontSize / 2, y * this.fontSize, this.fontSize, this.fontSize);\n        this.ctx.fillStyle = color;\n        this.ctx.fillText(ch, x * this.fontSize, y * this.fontSize + this.fontSize);\n    }\n    drawText(text, x, y, color = \"#AAA\") {\n        this.ctx.textAlign = \"left\";\n        /*\n        for (let i = 0; i < text.length; i++) {\n          this.drawChar(text.charAt(i), x + i, y, color);\n        }\n        */\n        this.ctx.fillStyle = \"#040414\";\n        this.ctx.fillStyle = color;\n        this.ctx.fillText(text, x * this.fontSize, y * this.fontSize + this.fontSize);\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, utils_1.debugInit)();\n            while (true) {\n                yield this.load();\n                yield this.gameloop();\n                yield this.save();\n                this.log.add(\"Press Esc to restart\", \"#FFF\");\n                this.render();\n                while (true) {\n                    const ch = yield this.getch();\n                    if (ch === \"Escape\")\n                        break;\n                }\n            }\n        });\n    }\n    waitingKeypress() {\n        return new Promise(resolve => {\n            document.addEventListener(\"keydown\", onKeyHandler);\n            function onKeyHandler(e) {\n                e.preventDefault();\n                if (e.keyCode !== 0) {\n                    document.removeEventListener(\"keydown\", onKeyHandler);\n                    exports.game.lastKey = e.key;\n                    resolve();\n                }\n            }\n        });\n    }\n    //wait keypress and return key\n    getch() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitingKeypress();\n            const tempKey = this.lastKey;\n            this.lastKey = \"\";\n            return tempKey;\n        });\n    }\n    render() {\n        this.clear();\n        (0, utils_1.ensure)(this.map).render();\n        const pl = (0, utils_1.ensure)(this.player);\n        this.drawChar(\"@\", pl.x, pl.y, \"#AAA\");\n        for (let i = 0; i < this.actors.length; i++)\n            this.actors[i].render();\n        this.renderUI();\n    }\n    renderUI() {\n        var _a, _b, _c, _d, _e, _f;\n        for (let x = 0; x < this.width; x++) {\n            this.drawChar(\"-\", x, this.height, \"#888\");\n        }\n        const pl = (0, utils_1.ensure)(this.player);\n        const hp = (_a = pl.destructible) === null || _a === void 0 ? void 0 : _a.hp;\n        const ac = (_b = pl.destructible) === null || _b === void 0 ? void 0 : _b.defense;\n        const maxHP = (_c = pl.destructible) === null || _c === void 0 ? void 0 : _c.maxHP;\n        const depth = (0, utils_1.ensure)(this.map).depth;\n        this.drawText(\"HP: \" + hp + \"/\" + maxHP, 1, this.height + 1);\n        this.drawText(\"AC: \" + ac, 7, this.height + 1);\n        this.drawText(\"Depth: \" + depth, this.width - 6, this.height + 1);\n        const padding = 8;\n        const offset = 14;\n        const abi = (_d = this.player) === null || _d === void 0 ? void 0 : _d.abilities;\n        this.drawText(`STR: ${abi === null || abi === void 0 ? void 0 : abi.str} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.STR)})`, offset, this.height + 1);\n        this.drawText(`DEX: ${abi === null || abi === void 0 ? void 0 : abi.dex} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.DEX)})`, offset + padding, this.height + 1);\n        this.drawText(`CON: ${abi === null || abi === void 0 ? void 0 : abi.con} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.CON)})`, offset + padding * 2, this.height + 1);\n        this.drawText(`INT: ${abi === null || abi === void 0 ? void 0 : abi.int} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.INT)})`, offset + padding * 3, this.height + 1);\n        this.drawText(`WIS: ${abi === null || abi === void 0 ? void 0 : abi.wis} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.WIS)})`, offset + padding * 4, this.height + 1);\n        this.drawText(\"EXP: \" +\n            ((_e = pl.destructible) === null || _e === void 0 ? void 0 : _e.xp) +\n            \" / \" +\n            ((_f = pl.ai) === null || _f === void 0 ? void 0 : _f.getNextLevelXP()), 60, this.height + 1);\n        this.log.render();\n    }\n    gameloop() {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            while (true) {\n                if (this.gameStatus === GameStatus.STARTUP) {\n                    (_a = this.player) === null || _a === void 0 ? void 0 : _a.computeFov();\n                    this.render();\n                }\n                this.gameStatus = GameStatus.IDLE;\n                yield ((_b = this.player) === null || _b === void 0 ? void 0 : _b.update());\n                if (this.gameStatus === GameStatus.NEW_TURN) {\n                    for (const actor of this.actors) {\n                        if (actor !== this.player) {\n                            yield actor.update();\n                        }\n                    }\n                }\n                //finally draw screen\n                this.render();\n                if (this.gameStatus === GameStatus.DEFEAT) {\n                    this.drawText(\"DEFEAT!\", this.width / 2 - 3, this.height / 2, \"#A00\");\n                    this.log.add(\"DEFEAT\", \"#A00\");\n                    break;\n                }\n            }\n        });\n    }\n    removeActor(actor) {\n        for (let i = 0; i < this.actors.length; i++) {\n            if (this.actors[i] === actor) {\n                this.actors.splice(i, 1);\n                return;\n            }\n        }\n    }\n    sendToBack(actor) {\n        this.removeActor(actor);\n        this.actors.unshift(actor);\n    }\n    getClosestMonster(x, y, range) {\n        let closest = null;\n        let bestDistance = 100000;\n        for (const actor of this.actors) {\n            if (actor != this.player &&\n                actor.destructible &&\n                !actor.destructible.isDead()) {\n                const distance = actor.getDistance(x, y);\n                if (distance < bestDistance && (distance <= range || range == 0.0)) {\n                    bestDistance = distance;\n                    closest = actor;\n                }\n            }\n        }\n        return closest;\n    }\n    getActor(x, y) {\n        for (const actor of this.actors) {\n            if (actor.x === x &&\n                actor.y === y &&\n                actor.destructible &&\n                !actor.destructible.isDead()) {\n                return actor;\n            }\n        }\n        return null;\n    }\n    pickATile(x, y, range = 0.0) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            let px = x;\n            let py = y;\n            let inRange = false;\n            while (true) {\n                this.render();\n                if (((_b = (_a = this.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.isInFov(px, py)) &&\n                    (range == 0 || this.player.getDistance(px, py) <= range)) {\n                    this.drawChar(\"+\", px, py, \"#FFF\");\n                    inRange = true;\n                }\n                else {\n                    this.drawChar(\"+\", px, py, \"#F88\");\n                    inRange = false;\n                }\n                const ch = yield this.getch();\n                if (ch === \"ArrowLeft\")\n                    px--;\n                if (ch === \"ArrowRight\")\n                    px++;\n                if (ch === \"ArrowUp\")\n                    py--;\n                if (ch === \"ArrowDown\")\n                    py++;\n                if (ch === \"Escape\")\n                    break;\n                if (ch === \"Enter\") {\n                    if (inRange) {\n                        return [true, px, py];\n                    }\n                }\n            }\n            return [false, px, py];\n        });\n    }\n}\nexports.game = new Game();\nexports.game.run();\n\n\n//# sourceURL=webpack://slanrl/./src/index.ts?");

/***/ }),

/***/ "./src/log.ts":
/*!********************!*\
  !*** ./src/log.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nclass LogText {\n    constructor(text, color) {\n        this.text = text;\n        this.color = color;\n    }\n}\nclass Log {\n    constructor() {\n        this.SIZE_OF_LOG = 100;\n        this.texts = [];\n    }\n    render() {\n        let a = 0;\n        for (let i = this.texts.length - 16; i < this.texts.length; i++) {\n            if (i >= 0) {\n                _1.game.drawText(this.texts[i].text, 1, _1.game.height + 3 + a, this.texts[i].color);\n                a++;\n            }\n        }\n    }\n    add(text, color = \"#AAA\") {\n        this.texts.push(new LogText(text, color));\n        if (this.texts.length > this.SIZE_OF_LOG) {\n            this.texts.splice(0, 1);\n        }\n    }\n}\nexports[\"default\"] = Log;\n\n\n//# sourceURL=webpack://slanrl/./src/log.ts?");

/***/ }),

/***/ "./src/map.ts":
/*!********************!*\
  !*** ./src/map.ts ***!
  \********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.random = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst actor_1 = __importDefault(__webpack_require__(/*! ./actor */ \"./src/actor.ts\"));\nconst ai_1 = __webpack_require__(/*! ./ai */ \"./src/ai.ts\");\nconst bsp_generator_1 = __importDefault(__webpack_require__(/*! ./bsp_generator */ \"./src/bsp_generator.ts\"));\nconst destructible_1 = __importDefault(__webpack_require__(/*! ./destructible */ \"./src/destructible.ts\"));\nconst monsterGenerator_1 = __webpack_require__(/*! ./monsterGenerator */ \"./src/monsterGenerator.ts\");\nconst pickable_1 = __importStar(__webpack_require__(/*! ./pickable */ \"./src/pickable.ts\"));\nconst random_1 = __importDefault(__webpack_require__(/*! ./random */ \"./src/random.ts\"));\nconst rectangle_1 = __importDefault(__webpack_require__(/*! ./rectangle */ \"./src/rectangle.ts\"));\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nexports.random = new random_1.default();\nclass Tile {\n    constructor() {\n        this.canWalk = false;\n        this.explored = false;\n    }\n}\nclass Map {\n    constructor(width, height) {\n        this.startX = 0;\n        this.startY = 0;\n        this.stairsX = 0;\n        this.stairsY = 0;\n        this.levelSeed = 0;\n        this.depth = 0;\n        this.ROOM_MAX_SIZE = 10;\n        this.ROOM_MIN_SIZE = 4;\n        this.MAX_ROOM_MONSTERS = 3;\n        this.MAX_ROOM_ITEMS = 2;\n        this.width = width;\n        this.height = height;\n    }\n    save() {\n        window.localStorage.setItem(\"seed\", this.levelSeed.toString());\n        window.localStorage.setItem(\"depth\", this.depth.toString());\n    }\n    isWall(x, y) {\n        const index = x + y * this.width;\n        return !this.tiles[index].canWalk;\n    }\n    setWall(x, y) {\n        this.tiles[x + y * this.width].canWalk = false;\n    }\n    canWalk(x, y) {\n        if (this.isWall(x, y))\n            return false;\n        for (const actor of _1.game.actors) {\n            if (actor.x === x && actor.y === y && actor.blocks) {\n                return false;\n            }\n        }\n        return true;\n    }\n    addMonster(x, y) {\n        const rng = exports.random.getInt(0, 100);\n        if (rng < 60) {\n            _1.game.actors.push((0, monsterGenerator_1.createMonster)(\"orc\", x, y));\n        }\n        else if (rng < 60 + 10) {\n            _1.game.actors.push((0, monsterGenerator_1.createMonster)(\"troll\", x, y));\n        }\n        else {\n            _1.game.actors.push((0, monsterGenerator_1.createMonster)(\"rat\", x, y));\n        }\n    }\n    openCloseDoor(x, y) {\n        const actor = _1.game.getActor(x, y);\n        if (actor && actor.name === \"door\") {\n            actor.blocks = !actor.blocks;\n            if (actor.blocks) {\n                actor.ch = \"D\";\n                _1.game.log.add(\"The door is closed\");\n            }\n            else {\n                actor.ch = \"+\";\n                _1.game.log.add(\"The door is opened\");\n            }\n            return true;\n        }\n        return false;\n    }\n    addDoor(x, y, closed) {\n        const door = new actor_1.default(x, y, closed ? \"D\" : \"+\", \"door\", \"#AA0\");\n        door.blocks = true;\n        door.destructible = new destructible_1.default(100, 0, \"broken door\", \"door\", 0);\n        _1.game.actors.push(door);\n    }\n    additem(x, y) {\n        const rng = exports.random.getInt(0, 100);\n        if (rng < 70) {\n            if (exports.random.getInt(0, 100) < 95) {\n                const healthPotion = new actor_1.default(x, y, \"!\", \"health potion\", \"#FF00FF\");\n                healthPotion.blocks = false;\n                healthPotion.pickable = new pickable_1.default(undefined, new pickable_1.HealthEffect(4, undefined));\n                _1.game.actors.push(healthPotion);\n                _1.game.sendToBack(healthPotion);\n            }\n            else {\n                const healthPotion = new actor_1.default(x, y, \"@\", \"Nutella bun\", \"#A80\");\n                healthPotion.blocks = false;\n                healthPotion.pickable = new pickable_1.default(undefined, new pickable_1.HealthEffect(30, undefined));\n                _1.game.actors.push(healthPotion);\n                _1.game.sendToBack(healthPotion);\n                console.log(\"Jossain haisoo nutella!\");\n            }\n        }\n        else if (rng < 70 + 10) {\n            const scrollOfLightingBolt = new actor_1.default(x, y, \"#\", \"scroll of lighting bolt\", \"#0FF\");\n            scrollOfLightingBolt.blocks = false;\n            //scrollOfLightingBolt.pickable = new LightningBolt(5, 20);\n            scrollOfLightingBolt.pickable = new pickable_1.default(new pickable_1.TargetSelector(pickable_1.SelectorType.CLOSEST_MONSTER, 5), new pickable_1.HealthEffect(-20, \"A lighting bolt strikes!\"));\n            _1.game.actors.push(scrollOfLightingBolt);\n            _1.game.sendToBack(scrollOfLightingBolt);\n        }\n        else if (rng < 70 + 20) {\n            const scrollOfFireball = new actor_1.default(x, y, \"#\", \"scroll of Fireball\", \"#FA0\");\n            scrollOfFireball.blocks = false;\n            //scrollOfFireball.pickable = new Fireball(2, 5);\n            scrollOfFireball.pickable = new pickable_1.default(new pickable_1.TargetSelector(pickable_1.SelectorType.SELECTED_RANGE, 3), new pickable_1.HealthEffect(-12, \"hurdur\"));\n            _1.game.actors.push(scrollOfFireball);\n            _1.game.sendToBack(scrollOfFireball);\n        }\n        else if (rng < 70 + 25) {\n            const scrollOfConfusion = new actor_1.default(x, y, \"#\", \"scroll of Confusion\", \"#FFA\");\n            scrollOfConfusion.blocks = false;\n            //scrollOfConfusion.pickable = new Confuser(10, 8);\n            scrollOfConfusion.pickable = new pickable_1.default(new pickable_1.TargetSelector(pickable_1.SelectorType.SELECTED_MONSTER, 5), new pickable_1.AiChangeEffect(new ai_1.ConfusedMonsterAi(10), \"confused af\"));\n            _1.game.actors.push(scrollOfConfusion);\n            _1.game.sendToBack(scrollOfConfusion);\n            //console.log(\"conf!\");\n        }\n        else {\n            const scrollOfConfusion = new actor_1.default(x, y, \"#\", \"scroll of Map\", \"#AA2\");\n            scrollOfConfusion.blocks = false;\n            //scrollOfConfusion.pickable = new Confuser(10, 8);\n            scrollOfConfusion.pickable = new pickable_1.default(undefined, new pickable_1.MapClearEffect(\"All is clear!\"));\n            _1.game.actors.push(scrollOfConfusion);\n            _1.game.sendToBack(scrollOfConfusion);\n            console.log(\"uulu!\");\n        }\n    }\n    dig(x1, y1, x2, y2, withActors) {\n        x1 = (0, utils_1.float2int)(x1);\n        x2 = (0, utils_1.float2int)(x2);\n        y1 = (0, utils_1.float2int)(y1);\n        y2 = (0, utils_1.float2int)(y2);\n        if (x2 < x1) {\n            const tmp = x2;\n            x2 = x1;\n            x1 = tmp;\n        }\n        if (y2 < y1) {\n            const tmp = y2;\n            y2 = y1;\n            y1 = tmp;\n        }\n        let lastWalkable = false;\n        for (let tilex = x1; tilex <= x2; tilex++) {\n            for (let tiley = y1; tiley <= y2; tiley++) {\n                const index = tilex + tiley * this.width;\n                if (this.tiles[index].canWalk == false &&\n                    lastWalkable === true &&\n                    (x1 === x2 || y1 === y2)) {\n                    if (withActors)\n                        this.addDoor(tilex, tiley, true);\n                }\n                lastWalkable = this.tiles[index].canWalk;\n                this.tiles[index].canWalk = true;\n            }\n        }\n    }\n    addActors(room) {\n        let numberOfMonsters = exports.random.getInt(0, this.MAX_ROOM_MONSTERS);\n        let numberOfItems = exports.random.getInt(0, this.MAX_ROOM_ITEMS);\n        //console.log(room);\n        const x1 = room.x;\n        const x2 = room.x + room.w;\n        const y1 = room.y;\n        const y2 = room.y + room.h;\n        while (numberOfMonsters > 0) {\n            const x = exports.random.getInt(x1, x2);\n            const y = exports.random.getInt(y1, y2);\n            if (this.canWalk(x, y)) {\n                this.addMonster(x, y);\n            }\n            numberOfMonsters--;\n        }\n        while (numberOfItems > 0) {\n            const x = exports.random.getInt(x1, x2);\n            const y = exports.random.getInt(y1, y2);\n            if (this.canWalk(x, y)) {\n                this.additem(x, y);\n            }\n            numberOfItems--;\n        }\n    }\n    createRoom(x1, y1, x2, y2, withActors) {\n        this.dig(x1, y1, x2, y2, withActors);\n        /*\n        this.stairsX = ((x1 + x2) / 2) | 0;\n        this.stairsY = ((y1 + y2) / 2) | 0;\n        \n        \n        this.startX = this.stairsX;\n        this.startY = this.stairsY;\n        */\n    }\n    generate(withActors, seed, depth) {\n        this.levelSeed = seed;\n        this.depth = depth;\n        exports.random.setSeed(this.levelSeed + depth * 25);\n        console.log(\"seed: \" + this.levelSeed);\n        console.log(\"depth: \" + this.depth);\n        const root = new bsp_generator_1.default(0, 0, this.width, this.height, 5);\n        this.tiles = new Array(this.width * this.height).fill(false);\n        const monsterRooms = [];\n        //const option = random.getInt(0, 2);\n        //console.log(\"option: \" + option);\n        const option = 2;\n        for (let i = 0; i < this.width * this.height; i++) {\n            this.tiles[i] = new Tile();\n            //we can use path/room data directly from bsp if we want.\n            //if (option === 0) this.tiles[i].canWalk = !this.root.map[i];\n        }\n        //lets create every room one by one\n        let lastx = 0;\n        let lasty = 0;\n        let x = 0;\n        let y = 0;\n        let w = 0;\n        let h = 0;\n        //take one room and make it spawn room\n        const spawnRoomIndex = exports.random.getInt(0, root.rooms.length - 1);\n        const stairsRoomIndex = exports.random.getInt(0, root.rooms.length - 1);\n        console.log(\"spwanroom index: \" + spawnRoomIndex + \" / \" + (root.rooms.length - 1));\n        for (let i = 0; i < root.rooms.length; i++) {\n            const room = root.rooms[i];\n            const spawnRoom = i === spawnRoomIndex ? true : false;\n            //option 1\n            /*\n            if (option === 1) {\n              w = room.w;\n              h = room.h;\n              x = room.x + 1;\n              y = room.y + 1;\n      \n              this.createRoom(x, y, x + w - 2, y + h - 2);\n              if (!spawnRoom) monsterRooms.push(new Rectangle(x, y, w - 2, h - 2));\n            }\n            */\n            //option 2\n            if (option === 2) {\n                w = exports.random.getInt(this.ROOM_MIN_SIZE, room.w - 2);\n                h = exports.random.getInt(this.ROOM_MIN_SIZE, room.h - 2);\n                x = exports.random.getInt(room.x, room.x + room.w - w - 0) + 1;\n                y = exports.random.getInt(room.y, room.y + room.h - h - 0) + 1;\n                this.createRoom(x, y, x + w - 2, y + h - 2, withActors);\n                if (!spawnRoom)\n                    monsterRooms.push(new rectangle_1.default(x, y, w - 2, h - 2));\n            }\n            if (i === spawnRoomIndex) {\n                this.startX = x + (0, utils_1.float2int)(w / 2);\n                this.startY = y + (0, utils_1.float2int)(h / 2);\n            }\n            if (i === stairsRoomIndex) {\n                this.stairsX = (0, utils_1.float2int)(x + w / 2);\n                this.stairsY = (0, utils_1.float2int)(y + h / 2);\n            }\n            if ( /*option === 1 ||*/option === 2) {\n                if (i > 0) {\n                    this.dig(lastx, lasty, x + w / 2, lasty, withActors);\n                    this.dig(x + w / 2, lasty, x + w / 2, y + h / 2, withActors);\n                }\n                lastx = x + w / 2;\n                lasty = y + h / 2;\n            }\n        }\n        if (withActors) {\n            for (const room of monsterRooms) {\n                this.addActors(room);\n            }\n        }\n    }\n    render() {\n        var _a, _b;\n        const darkWall = \"#\";\n        const darkGround = \".\";\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const fovValue = (_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.getMapped(x, y);\n                if (fovValue === 2 || fovValue === 1) {\n                    if (fovValue === 2) {\n                        _1.game.drawChar(this.isWall(x, y) ? darkWall : darkGround, x, y, \"#AAA\");\n                    }\n                    else {\n                        _1.game.drawChar(this.isWall(x, y) ? darkWall : darkGround, x, y, \"#444\");\n                    }\n                }\n            }\n        }\n    }\n}\nexports[\"default\"] = Map;\n\n\n//# sourceURL=webpack://slanrl/./src/map.ts?");

/***/ }),

/***/ "./src/menu.ts":
/*!*********************!*\
  !*** ./src/menu.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Menu = exports.MenuItemCode = exports.MenuItem = void 0;\nclass MenuItem {\n    constructor() {\n        this.code = 0;\n        this.label = \"\";\n    }\n}\nexports.MenuItem = MenuItem;\nvar MenuItemCode;\n(function (MenuItemCode) {\n    MenuItemCode[MenuItemCode[\"NONE\"] = 0] = \"NONE\";\n    MenuItemCode[MenuItemCode[\"NEW_GAME\"] = 1] = \"NEW_GAME\";\n    MenuItemCode[MenuItemCode[\"CONTINUE\"] = 2] = \"CONTINUE\";\n    MenuItemCode[MenuItemCode[\"EXIT\"] = 3] = \"EXIT\";\n    MenuItemCode[MenuItemCode[\"CONSTITUTION\"] = 4] = \"CONSTITUTION\";\n    MenuItemCode[MenuItemCode[\"STRENGTH\"] = 5] = \"STRENGTH\";\n    MenuItemCode[MenuItemCode[\"AGILITY\"] = 6] = \"AGILITY\";\n})(MenuItemCode = exports.MenuItemCode || (exports.MenuItemCode = {}));\nclass Menu {\n    constructor() {\n        this.items = [];\n    }\n    clear() {\n        if (this.items && this.items.length > 0)\n            this.items = [];\n    }\n    addItem(code, label) {\n        const item = new MenuItem();\n        item.code = code;\n        item.label = label;\n        this.items.push(item);\n    }\n}\nexports.Menu = Menu;\n\n\n//# sourceURL=webpack://slanrl/./src/menu.ts?");

/***/ }),

/***/ "./src/monsterGenerator.ts":
/*!*********************************!*\
  !*** ./src/monsterGenerator.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createMonster = void 0;\nconst abilities_1 = __webpack_require__(/*! ./abilities */ \"./src/abilities.ts\");\nconst actor_1 = __importDefault(__webpack_require__(/*! ./actor */ \"./src/actor.ts\"));\nconst ai_1 = __webpack_require__(/*! ./ai */ \"./src/ai.ts\");\nconst attacker_1 = __importDefault(__webpack_require__(/*! ./attacker */ \"./src/attacker.ts\"));\nconst destructible_1 = __webpack_require__(/*! ./destructible */ \"./src/destructible.ts\");\nconst createMonster = (name, x, y) => {\n    let power = 1;\n    let xp = 0;\n    let hp = 1;\n    let defense = 0;\n    let ch = \"?\";\n    let color = \"#F0F\";\n    let abi = new abilities_1.Abilities(2, 2, 2, 2, 2);\n    /*\n      List of enemies (candidates)\n      very Easy:\n        name,       depth:(1 - 5)\n        rat,\n        kobold,\n        dog,\n        cat,\n        roach,\n        turtle,\n        jackal\n      easy:         depth: (3 - 10)\n        hobgoblin,\n        imp,\n        jelly,\n        ooze,\n        lich,\n        lizard,\n        bat,\n        goblin\n      Medium:       depth: (8 - 15)\n        bear,\n        wolf,\n        golem,\n        insect,\n        mummy,\n        scorpion,\n        orc,\n        troll\n      Hard:         depth: (12 - 20)\n        elemental,\n        skeleton,\n        zombie,\n        lizardman,\n        demon\n    */\n    /*\n      Size of enemies:\n      tiny, small, medium, lardge, huge\n    */\n    //enemytypes:\n    /*\n      beasts,\n      dragons,\n      elementals,\n      giants,\n      humanoids,\n      monstrosities,\n      oozes,\n      plants,\n      undead,\n    */\n    if (name === \"rat\") {\n        ch = \"r\";\n        color = \"#999\";\n        power = 2;\n        defense = 0;\n        hp = 5;\n        xp = 2;\n        abi = new abilities_1.Abilities(2, 2, 2, 2, 2);\n    }\n    else if (name === \"ghoul\") {\n        //medium, undead\n        //ac: 12\n        //hp: 22\n        //str, dex, con, int, wis\n        //13,  15,  10,  7,   10\n        //Immunities: poison\n        //challenge: 1, 200xp\n        //actions:\n        //bite: melee, +2 hit, reach 5ft, 2d6+2 pierc\n        //claws: melee, +4, reach 5ft, 2d+2, slash\n        abi = new abilities_1.Abilities(13, 15, 10, 7, 10);\n    }\n    else if (name === \"giant rat\") {\n        //small, beast\n        //ac: 12\n        //hp: 7\n        //str, dex, con, int, wis\n        //7,   15,  11,   2,  10\n        //challenge: 1 / 8: 25xp\n        //actions:\n        //bite: melee, +4, reach 5ft, 1d4+2, pierc\n        abi = new abilities_1.Abilities(7, 15, 11, 2, 10);\n    }\n    else if (name === \"ogre\") {\n        //large, giant\n        //ac: 11\n        //hp:59\n        //str, dex, con, int, wis\n        //19,   8,  16,   5,  7\n        //challenge: 2: 450xp\n        //actions:\n        //creatclub: +6, reach 5ft, 2d8+4, bludg\n        abi = new abilities_1.Abilities(19, 8, 16, 5, 7);\n    }\n    else if (name === \"orc\") {\n        //medium humanoid\n        //ac: 13\n        //hp:15\n        //str, dex, con, int, wis\n        //16,   12,  16,  7,  11\n        //challenge: 1 / 2: 100xp\n        //actions:\n        //greataxe: +5, reach 5ft, 1d12+3, slash\n        abi = new abilities_1.Abilities(16, 12, 16, 7, 11);\n        power = 3;\n        xp = 10;\n        hp = 10;\n        defense = 0;\n        ch = \"o\";\n        color = \"#00AA00\";\n    }\n    else if (name === \"troll\") {\n        power = 5;\n        xp = 15;\n        hp = 15;\n        defense = 1;\n        ch = \"t\";\n        color = \"#008800\";\n    }\n    const monster = new actor_1.default(x, y, ch, name, color);\n    monster.destructible = new destructible_1.MonsterDestructible(hp, defense, `death ${name}`, xp);\n    monster.attacker = new attacker_1.default(power);\n    monster.ai = new ai_1.MonsterAI();\n    monster.abilities = abi;\n    return monster;\n};\nexports.createMonster = createMonster;\n\n\n//# sourceURL=webpack://slanrl/./src/monsterGenerator.ts?");

/***/ }),

/***/ "./src/pickable.ts":
/*!*************************!*\
  !*** ./src/pickable.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AiChangeEffect = exports.HealthEffect = exports.MapClearEffect = exports.TargetSelector = exports.SelectorType = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./src/index.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils.ts\");\nvar SelectorType;\n(function (SelectorType) {\n    SelectorType[SelectorType[\"NONE\"] = 0] = \"NONE\";\n    SelectorType[SelectorType[\"CLOSEST_MONSTER\"] = 1] = \"CLOSEST_MONSTER\";\n    SelectorType[SelectorType[\"SELECTED_MONSTER\"] = 2] = \"SELECTED_MONSTER\";\n    SelectorType[SelectorType[\"WEARER_RANGE\"] = 3] = \"WEARER_RANGE\";\n    SelectorType[SelectorType[\"SELECTED_RANGE\"] = 4] = \"SELECTED_RANGE\";\n})(SelectorType = exports.SelectorType || (exports.SelectorType = {}));\nclass TargetSelector {\n    constructor(type, range) {\n        this.type = type;\n        this.range = range;\n    }\n    selectTargets(wearer, listOfActors) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const handleSelectRange = () => __awaiter(this, void 0, void 0, function* () {\n                const [isOnRange, tileX, tileY] = yield _1.game.pickATile(wearer.x, wearer.y);\n                if (isOnRange === undefined || isOnRange === false) {\n                    return;\n                }\n                const actor = _1.game.getActor(tileX, tileY);\n                if (actor &&\n                    actor.destructible &&\n                    !actor.destructible.isDead() &&\n                    actor.getDistance(tileX, tileY) <= this.range) {\n                    listOfActors.push(actor);\n                }\n            });\n            const handleSelectClosestMonster = () => {\n                const actor = _1.game.getClosestMonster(wearer.x, wearer.y, this.range);\n                listOfActors.push(actor);\n            };\n            const handleSelectedMonster = () => __awaiter(this, void 0, void 0, function* () {\n                const [isOnRange, tileX, tileY] = yield _1.game.pickATile(wearer.x, wearer.y);\n                if (isOnRange === false) {\n                    return;\n                }\n                const actor = _1.game.getActor(tileX, tileY);\n                if (actor) {\n                    listOfActors.push(actor);\n                }\n            });\n            const handleWearerRange = () => {\n                for (const actor of _1.game.actors) {\n                    if (actor != wearer &&\n                        actor.destructible &&\n                        !actor.destructible.isDead() &&\n                        actor.getDistance(wearer.x, wearer.y) <= this.range) {\n                        listOfActors.push(actor);\n                    }\n                }\n            };\n            switch (this.type) {\n                case SelectorType.CLOSEST_MONSTER:\n                    handleSelectClosestMonster();\n                    break;\n                case SelectorType.SELECTED_MONSTER:\n                    yield handleSelectedMonster();\n                    break;\n                case SelectorType.WEARER_RANGE:\n                    handleWearerRange();\n                    break;\n                case SelectorType.SELECTED_RANGE:\n                    yield handleSelectRange();\n                    break;\n                default:\n                    console.error(`Error with selectorType: ${this.type}`);\n                    break;\n            }\n            if (listOfActors.length === 0) {\n                _1.game.log.add(\"No enemy is close enough\");\n            }\n        });\n    }\n}\nexports.TargetSelector = TargetSelector;\nclass MapClearEffect {\n    constructor(message) {\n        this.message = message;\n    }\n    applyTo(actor) {\n        var _a, _b, _c;\n        (0, utils_1.ensure)(actor);\n        (_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.showAll();\n        (_c = _1.game.player) === null || _c === void 0 ? void 0 : _c.computeFov();\n        return true;\n    }\n}\nexports.MapClearEffect = MapClearEffect;\nclass HealthEffect {\n    constructor(amount, message) {\n        this.amount = 0;\n        //super();\n        this.amount = amount;\n        this.message = message;\n    }\n    applyTo(actor) {\n        if (!actor || !actor.destructible)\n            return false;\n        if (this.amount > 0) {\n            //healing part\n            const pointsHealed = actor.destructible.heal(this.amount);\n            if (pointsHealed > 0) {\n                if (this.message) {\n                    _1.game.log.add(this.message, \"#AAA\");\n                }\n                return true;\n            }\n        }\n        else {\n            //hurting part\n            if (this.message && -this.amount - actor.destructible.defense > 0) {\n                _1.game.log.add(this.message, \"#AAA\");\n            }\n            if (actor.destructible.takeDamage(actor, -this.amount) > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.HealthEffect = HealthEffect;\nclass AiChangeEffect {\n    constructor(newAi, message) {\n        //super();\n        this.message = message;\n        this.newAi = newAi;\n    }\n    applyTo(actor) {\n        this.newAi.applyTo(actor);\n        if (this.message) {\n            _1.game.log.add(this.message);\n        }\n        return true;\n    }\n}\nexports.AiChangeEffect = AiChangeEffect;\nclass Pickable {\n    constructor(selector, effect) {\n        this.selector = selector;\n        this.effect = effect;\n        if (this.selector !== undefined) {\n            this.selectorName = this.selector.constructor.name;\n        }\n        if (this.effect !== undefined)\n            this.effectName = this.effect.constructor.name;\n    }\n    pick(owner, wearer) {\n        if (wearer.container && wearer.container.add(owner)) {\n            _1.game.removeActor(owner);\n            return true;\n        }\n        return false;\n    }\n    use(owner, wearer) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            _1.game.log.add(`You use a ${owner.name}`);\n            const actorList = Array();\n            if (this.selector) {\n                //console.log(\"1\");\n                yield this.selector.selectTargets(wearer, actorList);\n            }\n            else {\n                //console.log(\"2\");\n                actorList.push(wearer);\n            }\n            let succeed = false;\n            for (const actor of actorList) {\n                if ((_a = this.effect) === null || _a === void 0 ? void 0 : _a.applyTo(actor)) {\n                    succeed = true;\n                }\n            }\n            if (succeed) {\n                if (wearer.container) {\n                    wearer.container.remove(owner);\n                }\n            }\n            return succeed;\n        });\n    }\n    drop(owner, wearer) {\n        if (wearer.container) {\n            wearer.container.remove(owner);\n            _1.game.actors.push(owner);\n            _1.game.sendToBack(owner);\n            owner.x = wearer.x;\n            owner.y = wearer.y;\n            _1.game.log.add(`${wearer.name} drops a ${owner.name}`);\n        }\n    }\n}\nexports[\"default\"] = Pickable;\n\n\n//# sourceURL=webpack://slanrl/./src/pickable.ts?");

/***/ }),

/***/ "./src/random.ts":
/*!***********************!*\
  !*** ./src/random.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet _seed = 0;\nclass Randomizer {\n    constructor() {\n        this.rnd = 0;\n    }\n    setSeed(seed) {\n        _seed = seed;\n    }\n    calc() {\n        _seed = (_seed * 9301 + 49297) % 233280;\n        this.rnd = _seed / 233280.0;\n    }\n    getInt(min, max) {\n        max = max || 1;\n        min = min || 0;\n        this.calc();\n        return Math.floor(min + this.rnd * (max - min));\n    }\n    dice(dices, eyes, bonus) {\n        let v = 0;\n        eyes++;\n        for (let i = 0; i < dices; i++) {\n            v += Number(this.getInt(1, eyes));\n        }\n        v += +bonus;\n        if (v < dices)\n            v = dices;\n        return v;\n    }\n}\nexports[\"default\"] = Randomizer;\n\n\n//# sourceURL=webpack://slanrl/./src/random.ts?");

/***/ }),

/***/ "./src/rectangle.ts":
/*!**************************!*\
  !*** ./src/rectangle.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Rectangle {\n    constructor(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n    GetHalfDimensionX() {\n        return this.w / 2;\n    }\n    GetHalfDimensionY() {\n        return this.h / 2;\n    }\n    GetCenterX() {\n        return this.x + this.GetHalfDimensionX();\n    }\n    GetCenterY() {\n        return this.y + this.GetHalfDimensionY();\n    }\n}\nexports[\"default\"] = Rectangle;\n\n\n//# sourceURL=webpack://slanrl/./src/rectangle.ts?");

/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ensure = exports.float2int = exports.debugInit = exports.printVersionContainer = exports.populateVersion = exports.paddedLogObject = void 0;\nconst paddedLogObject = (object) => {\n    const maxKeyLength = Object.keys(object).reduce((previousValue, currentValue) => currentValue.length + 3 > previousValue\n        ? currentValue.length + 3\n        : previousValue, 0);\n    console.log(Object.keys(object)\n        .map(key => `${key.padEnd(maxKeyLength, \" \")}: ${object[key]}`)\n        .join(\"\\n\"));\n};\nexports.paddedLogObject = paddedLogObject;\nconst populateVersion = () => `Commit ID: <span>${\"aff08da\"}</span> | Version: <span>${\"v0.0.1.8a\"}</span>`;\nexports.populateVersion = populateVersion;\nconst printVersionContainer = () => {\n    document.querySelector(\"#version\").innerHTML = (0, exports.populateVersion)();\n};\nexports.printVersionContainer = printVersionContainer;\nconst debugInit = () => {\n    // Populates the content for \"version\" div in the bottom right corner\n    (0, exports.printVersionContainer)();\n    // Console logs a padded object\n    (0, exports.paddedLogObject)({\n        BUILD_DATE: \"2021-10-24\",\n        BUILD_TIME: \"18:45:59\",\n        BUILD_DATETIME: \"2021-10-24T18:45:59.785Z\",\n        COMMIT_HASH: \"aff08da\",\n        VERSION: \"v0.0.1.8a\",\n    });\n};\nexports.debugInit = debugInit;\nconst float2int = (value) => {\n    return value >> 0;\n};\nexports.float2int = float2int;\nconst ensure = (argument, message = \"This value was promised to be there.\") => {\n    if (argument === undefined || argument === null) {\n        throw new TypeError(message);\n    }\n    return argument;\n};\nexports.ensure = ensure;\n\n\n//# sourceURL=webpack://slanrl/./src/utils.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;