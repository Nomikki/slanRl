/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.game = exports.GameStatus = void 0;\nconst container_1 = __importDefault(__webpack_require__(/*! ./items/container */ \"./src/items/container.ts\"));\nconst equipments_1 = __importDefault(__webpack_require__(/*! ./items/equipments */ \"./src/items/equipments.ts\"));\nconst itemGenerator_1 = __webpack_require__(/*! ./items/itemGenerator */ \"./src/items/itemGenerator.ts\");\nconst camera_1 = __webpack_require__(/*! ./map/camera */ \"./src/map/camera.ts\");\nconst fov_1 = __importDefault(__webpack_require__(/*! ./map/fov */ \"./src/map/fov.ts\"));\n//import weaponsJson from \"./items.json\";\nconst map_1 = __importDefault(__webpack_require__(/*! ./map/map */ \"./src/map/map.ts\"));\nconst abilities_1 = __webpack_require__(/*! ./rpg/abilities */ \"./src/rpg/abilities.ts\");\nconst attacker_1 = __importDefault(__webpack_require__(/*! ./rpg/attacker */ \"./src/rpg/attacker.ts\"));\nconst actor_1 = __importDefault(__webpack_require__(/*! ./units/actor */ \"./src/units/actor.ts\"));\nconst ai_1 = __webpack_require__(/*! ./units/ai */ \"./src/units/ai.ts\");\nconst destructible_1 = __webpack_require__(/*! ./units/destructible */ \"./src/units/destructible.ts\");\nconst colors_1 = __webpack_require__(/*! ./utils/colors */ \"./src/utils/colors.ts\");\nconst log_1 = __importDefault(__webpack_require__(/*! ./utils/log */ \"./src/utils/log.ts\"));\nconst menu_1 = __webpack_require__(/*! ./utils/menu */ \"./src/utils/menu.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils/utils */ \"./src/utils/utils.ts\");\nvar GameStatus;\n(function (GameStatus) {\n    GameStatus[GameStatus[\"STARTUP\"] = 0] = \"STARTUP\";\n    GameStatus[GameStatus[\"IDLE\"] = 1] = \"IDLE\";\n    GameStatus[GameStatus[\"NEW_TURN\"] = 2] = \"NEW_TURN\";\n    GameStatus[GameStatus[\"VICTORY\"] = 3] = \"VICTORY\";\n    GameStatus[GameStatus[\"DEFEAT\"] = 4] = \"DEFEAT\";\n})(GameStatus = exports.GameStatus || (exports.GameStatus = {}));\n//const weapons: Weapon[] = weaponsJson;\n//const sword = weapons.find(({ name }: Weapon) => name === \"sword\");\nclass Game {\n    constructor() {\n        this.gameStatus = GameStatus.STARTUP;\n        this.masterSeed = 0;\n        this.turns = 0;\n        this.mapx = 80;\n        this.mapy = 80;\n        this.canvas = (0, utils_1.ensure)(document.getElementById(\"screen\"));\n        this.ctx = (0, utils_1.ensure)(this.canvas.getContext(\"2d\"));\n        this.ctx.font = \"12px system-ui\";\n        this.fontSize = 12;\n        this.ctx.textAlign = \"center\";\n        this.log = new log_1.default();\n        this.lastKey = \"\";\n        this.depth = 0;\n        this.turns = 0;\n        this.width = 80;\n        this.height = 40;\n        this.actors = [];\n        this.map = new map_1.default(this.mapx, this.mapy);\n        this.camera = new camera_1.Camera();\n        this.camera.setCenter(this.width, this.height);\n        //console.log(items);\n    }\n    term() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.log = new log_1.default();\n            this.actors = [];\n            this.map = new map_1.default(this.mapx, this.mapy);\n            this.player = undefined;\n        });\n    }\n    init(withActors, createPlayer = true) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, utils_1.ensure)(this.map).generate(withActors, this.masterSeed, this.depth);\n            if (withActors) {\n                let i = 0;\n                if (createPlayer) {\n                    i = this.actors.push(new actor_1.default(2, 2, \"@\", \"hero\", colors_1.Colors.HERO)) - 1;\n                    this.player = this.actors[i];\n                    this.player.destructible = new destructible_1.PlayerDestructible(30, 2, \"your cadaver\");\n                    this.player.attacker = new attacker_1.default(\"1d4\");\n                    this.player.ai = new ai_1.PlayerAI();\n                    this.player.abilities = new abilities_1.Abilities(18, 15, 10, 8, 12);\n                    this.player.container = new container_1.default(26);\n                    this.player.equipments = new equipments_1.default();\n                    this.player.fov = new fov_1.default(this.mapx, this.mapy);\n                }\n                (0, utils_1.ensure)(this.player).x = (0, utils_1.ensure)(this.map).startX;\n                (0, utils_1.ensure)(this.player).y = (0, utils_1.ensure)(this.map).startY;\n                (_a = (0, utils_1.ensure)(this.player).fov) === null || _a === void 0 ? void 0 : _a.fullClear();\n                i = this.actors.push(new actor_1.default(0, 0, \">\", \"stairs\", colors_1.Colors.STAIRS)) - 1;\n                this.stairs = this.actors[i];\n                this.stairs.blocks = false;\n                this.stairs.fovOnly = false;\n                this.stairs.x = (0, utils_1.ensure)(this.map).stairsX;\n                this.stairs.y = (0, utils_1.ensure)(this.map).stairsY;\n                this.sendToBack(this.stairs);\n                this.log.add(\"Welcome stranger!\");\n                const item = (0, itemGenerator_1.createItem)({\n                    name: \"leather armor\",\n                    x: (0, utils_1.ensure)(this.player).x,\n                    y: (0, utils_1.ensure)(this.player).y,\n                });\n                const item2 = (0, itemGenerator_1.createItem)({\n                    name: \"hide\",\n                    x: (0, utils_1.ensure)(this.player).x + 1,\n                    y: (0, utils_1.ensure)(this.player).y,\n                });\n                const item3 = (0, itemGenerator_1.createItem)({\n                    name: \"handaxe\",\n                    x: (0, utils_1.ensure)(this.player).x - 1,\n                    y: (0, utils_1.ensure)(this.player).y,\n                });\n                this.actors.push(item);\n                this.actors.push(item2);\n                this.actors.push(item3);\n            }\n            else {\n                this.log.add(\"Welcome back stranger!\");\n            }\n            this.gameStatus = GameStatus.STARTUP;\n        });\n    }\n    nextLevel() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.depth++;\n            this.log.add(\"You take steps down.\");\n            this.map = undefined;\n            this.stairs = undefined;\n            const tempPlayer = this.player;\n            this.actors = Array();\n            this.map = new map_1.default(this.mapx, this.mapy);\n            this.init(true, false);\n            this.actors.push(tempPlayer);\n            this.save();\n        });\n    }\n    newGame() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.masterSeed = (0, utils_1.float2int)(Math.random() * 0x7ffffff);\n            //this.masterSeed = 11038250;\n            this.turns = 0;\n            this.depth = 1;\n            yield this.term();\n            yield this.init(true, true);\n            yield this.save();\n        });\n    }\n    continueGame() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (window.localStorage.getItem(\"seed\") !== null) {\n                const savedVersion = window.localStorage.getItem(\"version\");\n                if (savedVersion === null)\n                    window.localStorage.setItem(\"version\", \"v0.0.1.12a\");\n                this.masterSeed = parseInt((0, utils_1.ensure)(window.localStorage.getItem(\"seed\")));\n                this.depth = parseInt((0, utils_1.ensure)(window.localStorage.getItem(\"depth\")));\n                this.turns = parseInt((0, utils_1.ensure)(window.localStorage.getItem(\"turns\")));\n                yield this.init(false);\n                const tempUsers = JSON.parse(window.localStorage.getItem(\"actors\") || \"[]\");\n                for (const actor of tempUsers) {\n                    const i = this.actors.push(new actor_1.default(actor.x, actor.y, actor.ch, actor.name, actor.color)) - 1;\n                    //this.actors[i].ai = undefined;\n                    if (actor.fov) {\n                        this.actors[i].fov = new fov_1.default(this.mapx, this.mapy);\n                        (0, utils_1.ensure)(this.actors[i].fov).mapped = actor.fov.mapped;\n                    }\n                    if (actor.container) {\n                        this.actors[i].container = yield new container_1.default(26);\n                        for (const it of actor.container.inventory) {\n                            const k = (0, utils_1.ensure)(this.actors[i].container).inventory.push(new actor_1.default(it.x, it.y, it.ch, it.name, it.color)) - 1;\n                            //ensure(this.actors[i].container).inventory[k].create(it);\n                            (0, utils_1.ensure)(this.actors[i].container).inventory[k] = (0, itemGenerator_1.createItem)({\n                                name: it.name,\n                                x: it.x,\n                                y: it.y,\n                            });\n                        }\n                    }\n                    if (actor.equipments) {\n                        this.actors[i].equipments = new equipments_1.default();\n                        for (const it of actor.equipments.items) {\n                            //console.log(\">>\");\n                            //console.log(it);\n                            //ensure(this.actors[i].equipments?.add(it));\n                            (0, utils_1.ensure)(this.actors[i].equipments).add((0, itemGenerator_1.createItem)({ name: it.name, x: it.x, y: it.y }));\n                            /*\n                            const k =\n                              ensure(this.actors[i].equipments).items.push(\n                                new Actor(it.x, it.y, it.ch, it.name, it.color),\n                              ) - 1;\n                            ensure(this.actors[i].equipments).add(it);\n                            */\n                        }\n                    }\n                    if (actor.abilities) {\n                        const abi = actor.abilities;\n                        this.actors[i].abilities = new abilities_1.Abilities(abi.str, abi.dex, abi.con, abi.int, abi.wis);\n                    }\n                    if (actor.attacker) {\n                        this.actors[i].attacker = new attacker_1.default(actor.attacker.power);\n                    }\n                    if (actor.pickable) {\n                        if (actor.armor || actor.weapon) {\n                            this.actors[i] = (0, itemGenerator_1.createItem)({\n                                name: actor.name,\n                                x: actor.x,\n                                y: actor.y,\n                            });\n                        }\n                        else {\n                            this.actors[i].create(actor);\n                        }\n                    }\n                    if (actor.name === \"stairs\") {\n                        this.stairs = this.actors[i];\n                        this.stairs.fovOnly = false;\n                    }\n                    if (actor.name === \"door\") {\n                        /*\n                        this.actors[i].destructible = new Destructible(\n                          100,\n                          0,\n                          \"broken door\",\n                          \"door\",\n                          0,\n                        );\n                        */\n                        this.actors[i].blocks = actor.blocks;\n                    }\n                    if (actor.destructible) {\n                        if (actor.destructible.type === \"player\") {\n                            this.player = this.actors[i];\n                            this.actors[i].destructible = new destructible_1.PlayerDestructible(30, 2, \"player corpse\");\n                            this.actors[i].ai = new ai_1.PlayerAI();\n                            (0, utils_1.ensure)(this.actors[i].destructible).xp = actor.destructible.xp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).hp = actor.destructible.hp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).maxHP =\n                                actor.destructible.maxHP;\n                            (0, utils_1.ensure)(this.actors[i].destructible).defense =\n                                actor.destructible.defense;\n                            (0, utils_1.ensure)(this.actors[i].destructible).corpseName =\n                                actor.destructible.corpseName;\n                        }\n                        if (actor.destructible.type === \"monster\") {\n                            this.actors[i].destructible = new destructible_1.MonsterDestructible(1, 1, \"monster corpse\", 0);\n                            (0, utils_1.ensure)(this.actors[i].destructible).xp = actor.destructible.xp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).hp = actor.destructible.hp;\n                            (0, utils_1.ensure)(this.actors[i].destructible).maxHP =\n                                actor.destructible.maxHP;\n                            (0, utils_1.ensure)(this.actors[i].destructible).defense =\n                                actor.destructible.defense;\n                            (0, utils_1.ensure)(this.actors[i].destructible).corpseName =\n                                actor.destructible.corpseName;\n                            this.actors[i].ai = new ai_1.MonsterAI();\n                        }\n                    }\n                }\n            }\n        });\n    }\n    load() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (window.localStorage.getItem(\"version\") !== \"v0.0.1.12a\")\n                window.localStorage.clear();\n            this.menu = new menu_1.Menu();\n            this.menu.clear();\n            if (window.localStorage.getItem(\"depth\"))\n                this.menu.addItem(menu_1.MenuItemCode.CONTINUE, \"Continue\");\n            this.menu.addItem(menu_1.MenuItemCode.NEW_GAME, \"New Game\");\n            let cursor = 0;\n            let selectedItem = -1;\n            while (true) {\n                this.clear();\n                this.drawChar(\">\", this.width / 2 - 12, 10 + cursor, colors_1.Colors.MENU_CURSOR);\n                for (let i = 0; i < this.menu.items.length; i++) {\n                    this.drawText(this.menu.items[i].label, this.width / 2 - 10, 10 + i);\n                }\n                const ch = yield this.getch();\n                if (ch === \"ArrowDown\")\n                    cursor++;\n                if (ch === \"ArrowUp\")\n                    cursor--;\n                if (ch === \"Enter\") {\n                    selectedItem = this.menu.items[cursor].code;\n                    break;\n                }\n                cursor = cursor % this.menu.items.length;\n                if (cursor < 0)\n                    cursor = this.menu.items.length - 1;\n            }\n            if (selectedItem != -1) {\n                if (selectedItem === menu_1.MenuItemCode.NEW_GAME) {\n                    yield this.newGame();\n                }\n                if (selectedItem === menu_1.MenuItemCode.CONTINUE) {\n                    yield this.continueGame();\n                }\n            }\n        });\n    }\n    save() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pl = (0, utils_1.ensure)(this.player);\n            if ((0, utils_1.ensure)(pl.destructible).isDead()) {\n                window.localStorage.clear();\n            }\n            else {\n                (0, utils_1.ensure)(this.map).save();\n                window.localStorage.setItem(\"playerID\", this.actors.indexOf(pl).toString());\n                window.localStorage.setItem(\"turns\", this.turns.toString());\n                window.localStorage.setItem(\"actors\", JSON.stringify(this.actors));\n                window.localStorage.setItem(\"version\", \"v0.0.1.12a\");\n            }\n        });\n    }\n    clear(color = colors_1.Colors.BACKGROUND) {\n        //Game\n        this.ctx.fillStyle = color;\n        this.ctx.fillRect(0, 0, this.width * this.fontSize, this.height * this.fontSize);\n        //\"UI\"\n        this.ctx.fillRect(0, this.height * this.fontSize, this.width * this.fontSize, this.canvas.height - this.height * this.fontSize);\n    }\n    saveImage() {\n        const tempW = this.width;\n        const tempH = this.height;\n        const oldCameraX = this.camera.x;\n        const oldCameraY = this.camera.y;\n        this.width = this.mapx;\n        this.height = this.mapy;\n        this.canvas = (0, utils_1.ensure)(document.getElementById(\"temp-image\"));\n        this.ctx = (0, utils_1.ensure)(this.canvas.getContext(\"2d\"));\n        this.ctx.canvas.width = this.mapx * this.fontSize;\n        this.ctx.canvas.height = this.mapy * this.fontSize;\n        this.camera.x = 0;\n        this.camera.y = 0;\n        this.clear();\n        (0, utils_1.ensure)(this.map).render();\n        for (let i = 0; i < this.actors.length; i++)\n            this.actors[i].render();\n        this.canvas = (0, utils_1.ensure)(document.getElementById(\"screen\"));\n        this.ctx = (0, utils_1.ensure)(this.canvas.getContext(\"2d\"));\n        this.width = tempW;\n        this.height = tempH;\n        this.camera.x = oldCameraX;\n        this.camera.y = oldCameraY;\n    }\n    drawChar(ch, x, y, color = colors_1.Colors.BACKGROUND) {\n        if (x < 0 || y < 0 || x > this.width || y > this.height) {\n            return;\n        }\n        this.ctx.textAlign = \"center\";\n        this.ctx.fillStyle = colors_1.Colors.BACKGROUND;\n        this.ctx.fillRect(x * this.fontSize - this.fontSize / 2, y * this.fontSize, this.fontSize, this.fontSize);\n        this.ctx.fillStyle = color;\n        this.ctx.fillText(ch, x * this.fontSize, y * this.fontSize + this.fontSize);\n    }\n    drawText(text, x, y, color = colors_1.Colors.DEFAULT_TEXT) {\n        this.ctx.textAlign = \"left\";\n        this.ctx.fillStyle = colors_1.Colors.BACKGROUND;\n        this.ctx.fillStyle = color;\n        this.ctx.fillText(text, x * this.fontSize, y * this.fontSize + this.fontSize);\n    }\n    run() {\n        return __awaiter(this, void 0, void 0, function* () {\n            (0, utils_1.debugInit)();\n            while (true) {\n                yield this.load();\n                yield this.gameloop();\n                yield this.save();\n                this.log.add(\"Press Esc to restart\");\n                this.render();\n                while (true) {\n                    const ch = yield this.getch();\n                    if (ch === \"Escape\")\n                        break;\n                }\n            }\n        });\n    }\n    waitingKeypress() {\n        return new Promise(resolve => {\n            document.addEventListener(\"keydown\", onKeyHandler);\n            function onKeyHandler(e) {\n                e.preventDefault();\n                if (e.keyCode !== 0) {\n                    document.removeEventListener(\"keydown\", onKeyHandler);\n                    exports.game.lastKey = e.key;\n                    resolve();\n                }\n            }\n        });\n    }\n    //wait keypress and return key\n    getch() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.waitingKeypress();\n            const tempKey = this.lastKey;\n            this.lastKey = \"\";\n            return tempKey;\n        });\n    }\n    render() {\n        this.clear();\n        (0, utils_1.ensure)(this.map).render();\n        for (let i = 0; i < this.actors.length; i++)\n            this.actors[i].render();\n        this.renderUI();\n    }\n    renderUI() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        for (let x = 0; x < this.width; x++) {\n            this.drawChar(\"-\", x, this.height, colors_1.Colors.MENU_BORDER);\n        }\n        const pl = (0, utils_1.ensure)(this.player);\n        const hp = (0, utils_1.ensure)((_a = pl.destructible) === null || _a === void 0 ? void 0 : _a.hp);\n        const ac = (_b = pl.destructible) === null || _b === void 0 ? void 0 : _b.defense;\n        const power = (_c = pl.attacker) === null || _c === void 0 ? void 0 : _c.power;\n        const maxHP = (0, utils_1.ensure)((_d = pl.destructible) === null || _d === void 0 ? void 0 : _d.maxHP);\n        const depth = (0, utils_1.ensure)(this.map).depth;\n        const turn = (0, utils_1.ensure)(this.turns);\n        const xp = (_e = pl.destructible) === null || _e === void 0 ? void 0 : _e.xp;\n        const getHpColor = () => {\n            if (hp < (maxHP / 100) * 10)\n                return colors_1.Colors.HP_10_PERCENT;\n            else if (hp < (maxHP / 100) * 25)\n                return colors_1.Colors.HP_25_PERCENT;\n            else if (hp < (maxHP / 100) * 50)\n                return colors_1.Colors.HP_50_PERCENT;\n            else if (hp < (maxHP / 100) * 95)\n                return colors_1.Colors.HP_95_PERENT;\n            return colors_1.Colors.HP_MAX;\n        };\n        this.drawText(\"HP: \" + hp + \"/\" + maxHP, 1, this.height + 1, getHpColor());\n        this.drawText(\"ATT: \" + power, 7, this.height + 1);\n        this.drawText(\"AC: \" + ac, 13, this.height + 1);\n        this.drawText(\"Depth: \" + depth, this.width - 6, this.height + 1);\n        this.drawText(\"Turn: \" + turn, this.width - 6, this.height + 2);\n        this.drawText(\"EXP: \" + xp + \" / \" + ((_f = pl.ai) === null || _f === void 0 ? void 0 : _f.getNextLevelXP()), 1, this.height + 2);\n        const padding = 8;\n        const offset = 19;\n        const abi = (_g = this.player) === null || _g === void 0 ? void 0 : _g.abilities;\n        this.drawText(`STR: ${abi === null || abi === void 0 ? void 0 : abi.str} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.STR)})`, offset, this.height + 1);\n        this.drawText(`DEX: ${abi === null || abi === void 0 ? void 0 : abi.dex} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.DEX)})`, offset + padding, this.height + 1);\n        this.drawText(`CON: ${abi === null || abi === void 0 ? void 0 : abi.con} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.CON)})`, offset + padding * 2, this.height + 1);\n        this.drawText(`INT: ${abi === null || abi === void 0 ? void 0 : abi.int} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.INT)})`, offset + padding * 3, this.height + 1);\n        this.drawText(`WIS: ${abi === null || abi === void 0 ? void 0 : abi.wis} (${abi === null || abi === void 0 ? void 0 : abi.getBonusWithSign(abilities_1.ABILITIES.WIS)})`, offset + padding * 4, this.height + 1);\n        this.log.render();\n        this.drawText(\"Weared\", this.width - 20, this.height + 3);\n        let a = 0;\n        if (pl.equipments && ((_h = pl.equipments) === null || _h === void 0 ? void 0 : _h.items.length) > 0) {\n            for (const actor of (0, utils_1.ensure)((_j = pl.equipments) === null || _j === void 0 ? void 0 : _j.items)) {\n                this.drawText(actor.name, this.width - 20, this.height + 4 + a);\n                a++;\n            }\n        }\n    }\n    gameloop() {\n        var _a, _b, _c, _d, _e, _f;\n        return __awaiter(this, void 0, void 0, function* () {\n            while (true) {\n                if (this.gameStatus === GameStatus.STARTUP) {\n                    (_a = this.player) === null || _a === void 0 ? void 0 : _a.computeFov();\n                    this.camera.compute((0, utils_1.ensure)((_b = this.player) === null || _b === void 0 ? void 0 : _b.x), (0, utils_1.ensure)((_c = this.player) === null || _c === void 0 ? void 0 : _c.y));\n                    this.render();\n                }\n                this.gameStatus = GameStatus.IDLE;\n                yield ((_d = this.player) === null || _d === void 0 ? void 0 : _d.update());\n                if (this.gameStatus === GameStatus.NEW_TURN) {\n                    for (const actor of this.actors) {\n                        if (actor !== this.player) {\n                            yield actor.update();\n                        }\n                    }\n                    this.turns++;\n                }\n                //finally draw screen\n                this.render();\n                if (this.gameStatus === GameStatus.DEFEAT) {\n                    this.drawText(\"DEFEAT!\", this.width / 2 - 3, this.height / 2, colors_1.Colors.DEFEAT);\n                    this.log.add(\"DEFEAT\", colors_1.Colors.DEFEAT);\n                    (_f = (_e = this.player) === null || _e === void 0 ? void 0 : _e.fov) === null || _f === void 0 ? void 0 : _f.showAll();\n                    this.saveImage();\n                    break;\n                }\n            }\n        });\n    }\n    removeActor(actor) {\n        for (let i = 0; i < this.actors.length; i++) {\n            if (this.actors[i] === actor) {\n                this.actors.splice(i, 1);\n                return;\n            }\n        }\n    }\n    sendToBack(actor) {\n        this.removeActor(actor);\n        this.actors.unshift(actor);\n    }\n    getClosestMonster(x, y, range) {\n        let closest = null;\n        let bestDistance = 100000;\n        for (const actor of this.actors) {\n            if (actor != this.player &&\n                actor.destructible &&\n                !actor.destructible.isDead()) {\n                const distance = actor.getDistance(x, y);\n                if (distance < bestDistance && (distance <= range || range == 0.0)) {\n                    bestDistance = distance;\n                    closest = actor;\n                }\n            }\n        }\n        return closest;\n    }\n    getActor(x, y) {\n        for (const actor of this.actors) {\n            if (actor.x === x &&\n                actor.y === y &&\n                actor.destructible &&\n                !actor.destructible.isDead()) {\n                return actor;\n            }\n        }\n        return null;\n    }\n    getAnyActor(x, y) {\n        for (const actor of this.actors) {\n            if (actor.x === x && actor.y === y) {\n                return actor;\n            }\n        }\n        return null;\n    }\n    pickATile(x, y, range = 0.0) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            let px = x;\n            let py = y;\n            let inRange = false;\n            while (true) {\n                this.render();\n                if (((_b = (_a = this.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.isInFov(px, py)) &&\n                    (range == 0 || this.player.getDistance(px, py) <= range)) {\n                    this.drawChar(\"+\", px + this.camera.x, py + this.camera.y, colors_1.Colors.ALLOWED);\n                    inRange = true;\n                }\n                else {\n                    this.drawChar(\"+\", px + this.camera.x, py + this.camera.y, colors_1.Colors.DISALLOWED);\n                    inRange = false;\n                }\n                const ch = yield this.getch();\n                if (ch === \"ArrowLeft\")\n                    px--;\n                if (ch === \"ArrowRight\")\n                    px++;\n                if (ch === \"ArrowUp\")\n                    py--;\n                if (ch === \"ArrowDown\")\n                    py++;\n                if (ch === \"Escape\")\n                    break;\n                if (ch === \"Enter\") {\n                    if (inRange) {\n                        return [true, px, py];\n                    }\n                }\n            }\n            return [false, px, py];\n        });\n    }\n}\nexports.game = new Game();\nexports.game.run();\n\n\n//# sourceURL=webpack://slanrl/./src/index.ts?");

/***/ }),

/***/ "./src/items/container.ts":
/*!********************************!*\
  !*** ./src/items/container.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst armor_1 = __webpack_require__(/*! ../rpg/armor */ \"./src/rpg/armor.ts\");\nconst weapon_1 = __webpack_require__(/*! ../rpg/weapon */ \"./src/rpg/weapon.ts\");\nconst colors_1 = __webpack_require__(/*! ../utils/colors */ \"./src/utils/colors.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nconst pickable_1 = __webpack_require__(/*! ./pickable */ \"./src/items/pickable.ts\");\nclass Container {\n    constructor(size) {\n        this.size = size; //maximum number of actors\n        this.inventory = [];\n    }\n    add(actor) {\n        if (this.size > 0 && this.inventory.length >= this.size) {\n            //inventory is full\n            return false;\n        }\n        else {\n            this.inventory.push(actor);\n            return true;\n        }\n    }\n    remove(actor) {\n        for (let i = 0; i < this.inventory.length; i++) {\n            if (this.inventory[i] === actor) {\n                this.inventory.splice(i, 1);\n                return;\n            }\n        }\n    }\n    renderMenuBackground({ title, x, y, w, h }) {\n        for (let yy = 0; yy < h; yy++) {\n            for (let xx = 0; xx < w; xx++) {\n                if ((yy === 0 || yy === h - 1) && xx > 0 && xx < w - 1)\n                    _1.game.drawChar(\"-\", xx + x, yy + y, colors_1.Colors.MENU_BORDER);\n                else if ((xx === 0 || xx === w - 1) && yy > 0 && yy < h - 1)\n                    _1.game.drawChar(\"|\", xx + x, yy + y, colors_1.Colors.MENU_BORDER);\n                else if (yy === 0 || xx === 0 || yy === h - 1 || xx === w - 1)\n                    _1.game.drawChar(\"+\", xx + x, yy + y, colors_1.Colors.MENU_BORDER);\n                else\n                    _1.game.drawChar(\" \", xx + x, yy + y, colors_1.Colors.MENU_BORDER);\n            }\n        }\n        //game.drawText(\" INVENTORY \", 34, 0);\n        for (let i = 0; i < title.length; i++) {\n            _1.game.drawChar(title.charAt(i), x + w / 2 - title.length / 2 + i, y, colors_1.Colors.DEFAULT_TEXT);\n        }\n    }\n    render() {\n        var _a, _b, _c, _d;\n        this.renderMenuBackground({\n            title: \"INVENTORY\",\n            x: 15,\n            y: 4,\n            w: 45,\n            h: 30,\n        });\n        let shortcut = \"a\";\n        let i = 0;\n        const menuStartY = 6;\n        for (const it of this.inventory) {\n            _1.game.drawText(shortcut + \") \" + it.name, 16, menuStartY + i);\n            const weight = (0, utils_1.ensure)(it.pickable).weight;\n            _1.game.drawText(`${weight} lb`, 54, menuStartY + i);\n            shortcut = String.fromCharCode(shortcut.charCodeAt(0) + 1);\n            let propertiesText = \"\";\n            if (it.armor) {\n                if (it.armor.armorType === armor_1.ArmorType.SHIELD)\n                    propertiesText = `AC: ${it.armor.armorClass}, shield`;\n                if (it.armor.armorType === armor_1.ArmorType.LIGHT_ARMOR)\n                    propertiesText = `AC: ${it.armor.armorClass}, light armor`;\n                if (it.armor.armorType === armor_1.ArmorType.MEDIUM_ARMOR)\n                    propertiesText = `AC: ${it.armor.armorClass}, medium armor`;\n                if (it.armor.armorType === armor_1.ArmorType.HEAVY_ARMOR)\n                    propertiesText = `AC: ${it.armor.armorClass}, heavy armor`;\n            }\n            if (it.weapon) {\n                if (it.weapon.damageType === weapon_1.DamageType.BLUDGEONING)\n                    propertiesText = `damage: ${it.weapon.damage}, bludgeoning`;\n                if (it.weapon.damageType === weapon_1.DamageType.PIERCING)\n                    propertiesText = `damage: ${it.weapon.damage}, piercing`;\n                if (it.weapon.damageType === weapon_1.DamageType.SLASHING)\n                    propertiesText = `damage: ${it.weapon.damage}, slashing`;\n            }\n            if ((_a = it.pickable) === null || _a === void 0 ? void 0 : _a.effect) {\n                let effectText = \"\";\n                if (it.pickable.effectName === \"HealthEffect\") {\n                    if (it.pickable.effect.amount > 0) {\n                        effectText = `healing: ${Math.abs(it.pickable.effect.amount)}`;\n                    }\n                    else {\n                        effectText = `damage: ${Math.abs(it.pickable.effect.amount)}`;\n                    }\n                }\n                if (it.pickable.effectName === \"AiChangeEffect\") {\n                    effectText = `confused ${it.pickable.effect.newAi.nbTurns} turns`;\n                }\n                if (it.name === \"scroll of map\") {\n                    effectText = \"Reveal current map\";\n                }\n                propertiesText += `${effectText}`;\n                if ((_b = it.pickable) === null || _b === void 0 ? void 0 : _b.selector) {\n                    propertiesText += \", \";\n                }\n            }\n            if ((_c = it.pickable) === null || _c === void 0 ? void 0 : _c.selector) {\n                let selectorText = \"\";\n                const range = it.pickable.selector.range;\n                if (it.pickable.selector.type === pickable_1.SelectorType.CLOSEST_MONSTER)\n                    selectorText = \"closest enemy\";\n                if (it.pickable.selector.type === pickable_1.SelectorType.SELECTED_MONSTER)\n                    selectorText = \"selected monster\";\n                if (it.pickable.selector.type === pickable_1.SelectorType.SELECTED_RANGE)\n                    selectorText = \"selected range\";\n                if (it.pickable.selector.type === pickable_1.SelectorType.WEARER_RANGE)\n                    selectorText = \"wearer range\";\n                propertiesText += `${selectorText}, range: ${range}`;\n            }\n            if (((_d = it.pickable) === null || _d === void 0 ? void 0 : _d.effect) && it.pickable.effectName === \"Wearable\") {\n                if (it.pickable.effect.type === pickable_1.WearableType.ONEHANDED_WEAPON)\n                    propertiesText += \", one-handed\";\n                if (it.pickable.effect.type === pickable_1.WearableType.TWOHANDED_WEAPON)\n                    propertiesText += \", two-handed\";\n                if (it.pickable.effect.type === pickable_1.WearableType.SHIELD)\n                    propertiesText += \", shield\";\n                if (it.pickable.effect.type === pickable_1.WearableType.ARMOR)\n                    propertiesText += \", armor\";\n            }\n            _1.game.drawText(`${propertiesText}`, 30, menuStartY + i);\n            i++;\n        }\n    }\n}\nexports[\"default\"] = Container;\n\n\n//# sourceURL=webpack://slanrl/./src/items/container.ts?");

/***/ }),

/***/ "./src/items/equipments.ts":
/*!*********************************!*\
  !*** ./src/items/equipments.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nclass Equipments {\n    constructor() {\n        this.items = [];\n    }\n    add(actor) {\n        this.items.push(actor);\n        return true;\n    }\n    takeOff(type) {\n        var _a, _b;\n        for (let i = 0; i < this.items.length; i++) {\n            if (((_a = this.items[i].pickable) === null || _a === void 0 ? void 0 : _a.effect) &&\n                ((_b = this.items[i].pickable) === null || _b === void 0 ? void 0 : _b.effect.type) === type) {\n                const temp = this.items.splice(i, 1);\n                return temp[0];\n            }\n        }\n        return undefined;\n    }\n    getAC() {\n        let ac = 0;\n        for (const item of this.items) {\n            if (item.armor) {\n                ac += item.armor.armorClass;\n            }\n        }\n        return ac;\n    }\n    getPower() {\n        let dmg = \"1d3\";\n        for (const item of this.items) {\n            if (item.weapon) {\n                dmg = item.weapon.damage;\n            }\n        }\n        return dmg;\n    }\n    update(owner) {\n        if (owner.destructible) {\n            (0, utils_1.ensure)(owner === null || owner === void 0 ? void 0 : owner.destructible).defense = this.getAC();\n            (0, utils_1.ensure)(owner.attacker).power = this.getPower();\n        }\n    }\n}\nexports[\"default\"] = Equipments;\n\n\n//# sourceURL=webpack://slanrl/./src/items/equipments.ts?");

/***/ }),

/***/ "./src/items/itemGenerator.ts":
/*!************************************!*\
  !*** ./src/items/itemGenerator.ts ***!
  \************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createItem = exports.items = exports.weapons = exports.armors = void 0;\nconst armors_json_1 = __importDefault(__webpack_require__(/*! ../data/armors.json */ \"./src/data/armors.json\"));\nconst items_json_1 = __importDefault(__webpack_require__(/*! ../data/items.json */ \"./src/data/items.json\"));\nconst weapons_json_1 = __importDefault(__webpack_require__(/*! ../data/weapons.json */ \"./src/data/weapons.json\"));\nconst armor_1 = __importStar(__webpack_require__(/*! ../rpg/armor */ \"./src/rpg/armor.ts\"));\nconst weapon_1 = __importStar(__webpack_require__(/*! ../rpg/weapon */ \"./src/rpg/weapon.ts\"));\nconst actor_1 = __importDefault(__webpack_require__(/*! ../units/actor */ \"./src/units/actor.ts\"));\nconst ai_1 = __webpack_require__(/*! ../units/ai */ \"./src/units/ai.ts\");\nconst colors_1 = __webpack_require__(/*! ../utils/colors */ \"./src/utils/colors.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nconst pickable_1 = __importStar(__webpack_require__(/*! ./pickable */ \"./src/items/pickable.ts\"));\nexports.armors = armors_json_1.default;\nexports.weapons = weapons_json_1.default;\nexports.items = items_json_1.default;\nconst getArmorUsingFind = (name) => {\n    return exports.armors.find(item => item.name === name);\n};\nconst getWeaponsUsingFind = (name) => {\n    return exports.weapons.find(item => item.name === name);\n};\nconst getItemsUsingFind = (name) => {\n    return exports.items.find(item => item.name === name);\n};\nconst createItem = (props) => {\n    let ch = \"?\";\n    let color = \"#F0F\";\n    let blocks = false;\n    let pickable = undefined;\n    let armor = undefined;\n    let weapon = undefined;\n    let armorType = armor_1.ArmorType.LIGHT_ARMOR;\n    const isArmor = (name) => !!exports.armors.find(n => n.name === name);\n    const isWeapon = (name) => !!exports.weapons.find(n => n.name === name);\n    const isItem = (name) => !!exports.items.find(n => n.name === name);\n    /*\n    const isArmor = (name: string): boolean => {\n      for (const n of armors) {\n        if (n.name === name) return true;\n      }\n      return false;\n    };\n  \n    const isWeapon = (name: string): boolean => {\n      for (const n of weapons) {\n        if (n.name === name) return true;\n      }\n      return false;\n    };\n  \n    const isItem = (name: string): boolean => {\n      for (const n of items) {\n        if (n.name === name) return true;\n      }\n      return false;\n    };\n    */\n    //simple melee weapons\n    if (isWeapon(props.name)) {\n        const weaponTemplate = (0, utils_1.ensure)(getWeaponsUsingFind(props.name));\n        let damageType = weapon_1.DamageType.BLUDGEONING;\n        let wearableType = pickable_1.WearableType.ONEHANDED_WEAPON;\n        if (weaponTemplate.damageType === \"bludgeoning\")\n            damageType = weapon_1.DamageType.BLUDGEONING;\n        if (weaponTemplate.damageType === \"slashing\")\n            damageType = weapon_1.DamageType.SLASHING;\n        if (weaponTemplate.damageType === \"piercing\")\n            damageType = weapon_1.DamageType.PIERCING;\n        if (weaponTemplate.wearableType === \"one-handed\")\n            wearableType = pickable_1.WearableType.ONEHANDED_WEAPON;\n        if (weaponTemplate.wearableType === \"two-handed\")\n            wearableType = pickable_1.WearableType.TWOHANDED_WEAPON;\n        weapon = new weapon_1.default({\n            name: props.name,\n            damage: weaponTemplate === null || weaponTemplate === void 0 ? void 0 : weaponTemplate.damage,\n            damageType: damageType,\n        });\n        ch = \"F\";\n        color = colors_1.Colors.WEAPON_ITEM;\n        blocks = false;\n        pickable = new pickable_1.default({\n            selector: undefined,\n            effect: new pickable_1.Wearable(wearableType),\n            weight: weaponTemplate.weight,\n        });\n    }\n    //simple ranged weapons\n    //armors\n    else if (isArmor(props.name)) {\n        const armorTemplate = (0, utils_1.ensure)(getArmorUsingFind(props.name));\n        if (armorTemplate.armorType === \"light\")\n            armorType = armor_1.ArmorType.LIGHT_ARMOR;\n        if (armorTemplate.armorType === \"medium\")\n            armorType = armor_1.ArmorType.MEDIUM_ARMOR;\n        if (armorTemplate.armorType === \"heavy\")\n            armorType = armor_1.ArmorType.HEAVY_ARMOR;\n        if (armorTemplate.armorType === \"shield\")\n            armorType = armor_1.ArmorType.SHIELD;\n        armor = new armor_1.default({\n            name: props.name,\n            ac: armorTemplate.ac,\n            armorClassAbilityType: armorType === armor_1.ArmorType.HEAVY_ARMOR ? \"str\" : \"dex\",\n            armorType: armorType,\n            requirementStrenght: 0,\n        });\n        ch = \"L\";\n        color = colors_1.Colors.ARMOR_ITEM;\n        blocks = false;\n        pickable = new pickable_1.default({\n            selector: undefined,\n            effect: new pickable_1.Wearable(armorType === armor_1.ArmorType.SHIELD\n                ? pickable_1.WearableType.SHIELD\n                : pickable_1.WearableType.ARMOR),\n            weight: armorTemplate.weight,\n        });\n    }\n    else if (isItem(props.name)) {\n        const itemTemplate = (0, utils_1.ensure)(getItemsUsingFind(props.name));\n        ch = itemTemplate.ch;\n        color = itemTemplate.color;\n        blocks = false;\n        let selector = undefined;\n        let effect = undefined;\n        if (itemTemplate.selector.type === \"selected range\")\n            selector = new pickable_1.TargetSelector(pickable_1.SelectorType.SELECTED_RANGE, itemTemplate.selector.range);\n        if (itemTemplate.selector.type === \"selected monster\")\n            selector = new pickable_1.TargetSelector(pickable_1.SelectorType.SELECTED_MONSTER, itemTemplate.selector.range);\n        if (itemTemplate.selector.type === \"closest monster\")\n            selector = new pickable_1.TargetSelector(pickable_1.SelectorType.CLOSEST_MONSTER, itemTemplate.selector.range);\n        if (itemTemplate.effect.type === \"health\")\n            effect = new pickable_1.HealthEffect(itemTemplate.effect.amount, itemTemplate.message);\n        if (itemTemplate.effect.type === \"map clear\")\n            effect = new pickable_1.MapClearEffect(itemTemplate.message);\n        if (itemTemplate.effect.type === \"change ai\")\n            effect = new pickable_1.AiChangeEffect(new ai_1.ConfusedMonsterAi(itemTemplate.effect.amount), itemTemplate.message);\n        pickable = new pickable_1.default({\n            selector: selector,\n            effect: effect,\n            weight: itemTemplate.weight,\n        });\n    }\n    else {\n        console.error(`${name} not found.`);\n    }\n    const item = new actor_1.default(props.x, props.y, ch, props.name, color);\n    item.blocks = blocks;\n    item.pickable = pickable;\n    item.armor = armor;\n    item.weapon = weapon;\n    return item;\n};\nexports.createItem = createItem;\n\n\n//# sourceURL=webpack://slanrl/./src/items/itemGenerator.ts?");

/***/ }),

/***/ "./src/items/pickable.ts":
/*!*******************************!*\
  !*** ./src/items/pickable.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AiChangeEffect = exports.HealthEffect = exports.Wearable = exports.WearableType = exports.MapClearEffect = exports.TargetSelector = exports.SelectorType = void 0;\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst colors_1 = __webpack_require__(/*! ../utils/colors */ \"./src/utils/colors.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nvar SelectorType;\n(function (SelectorType) {\n    SelectorType[SelectorType[\"NONE\"] = 0] = \"NONE\";\n    SelectorType[SelectorType[\"CLOSEST_MONSTER\"] = 1] = \"CLOSEST_MONSTER\";\n    SelectorType[SelectorType[\"SELECTED_MONSTER\"] = 2] = \"SELECTED_MONSTER\";\n    SelectorType[SelectorType[\"WEARER_RANGE\"] = 3] = \"WEARER_RANGE\";\n    SelectorType[SelectorType[\"SELECTED_RANGE\"] = 4] = \"SELECTED_RANGE\";\n})(SelectorType = exports.SelectorType || (exports.SelectorType = {}));\nclass TargetSelector {\n    constructor(type, range) {\n        this.type = type;\n        this.range = range;\n    }\n    selectTargets(wearer, listOfActors) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const handleSelectRange = () => __awaiter(this, void 0, void 0, function* () {\n                const [isOnRange, tileX, tileY] = yield _1.game.pickATile(wearer.x, wearer.y);\n                if (isOnRange === undefined || isOnRange === false) {\n                    return;\n                }\n                const actor = _1.game.getActor(tileX, tileY);\n                if (actor &&\n                    actor.destructible &&\n                    !actor.destructible.isDead() &&\n                    actor.getDistance(tileX, tileY) <= this.range) {\n                    listOfActors.push(actor);\n                }\n            });\n            const handleSelectClosestMonster = () => {\n                const actor = _1.game.getClosestMonster(wearer.x, wearer.y, this.range);\n                if (actor)\n                    listOfActors.push(actor);\n            };\n            const handleSelectedMonster = () => __awaiter(this, void 0, void 0, function* () {\n                const [isOnRange, tileX, tileY] = yield _1.game.pickATile(wearer.x, wearer.y);\n                if (isOnRange === false) {\n                    return;\n                }\n                const actor = _1.game.getActor(tileX, tileY);\n                if (actor) {\n                    listOfActors.push(actor);\n                }\n            });\n            const handleWearerRange = () => {\n                for (const actor of _1.game.actors) {\n                    if (actor != wearer &&\n                        actor.destructible &&\n                        !actor.destructible.isDead() &&\n                        actor.getDistance(wearer.x, wearer.y) <= this.range) {\n                        listOfActors.push(actor);\n                    }\n                }\n            };\n            switch (this.type) {\n                case SelectorType.CLOSEST_MONSTER:\n                    handleSelectClosestMonster();\n                    break;\n                case SelectorType.SELECTED_MONSTER:\n                    yield handleSelectedMonster();\n                    break;\n                case SelectorType.WEARER_RANGE:\n                    handleWearerRange();\n                    break;\n                case SelectorType.SELECTED_RANGE:\n                    yield handleSelectRange();\n                    break;\n                default:\n                    console.error(`Error with selectorType: ${this.type}`);\n                    break;\n            }\n            if (listOfActors.length === 0) {\n                _1.game.log.add(\"No enemy is close enough\");\n            }\n        });\n    }\n}\nexports.TargetSelector = TargetSelector;\nclass MapClearEffect {\n    constructor(message) {\n        this.message = message;\n    }\n    applyTo(actor) {\n        var _a, _b, _c;\n        (0, utils_1.ensure)(actor);\n        (_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.showAll();\n        (_c = _1.game.player) === null || _c === void 0 ? void 0 : _c.computeFov();\n        return true;\n    }\n}\nexports.MapClearEffect = MapClearEffect;\nvar WearableType;\n(function (WearableType) {\n    WearableType[WearableType[\"ARMOR\"] = 0] = \"ARMOR\";\n    WearableType[WearableType[\"SHIELD\"] = 1] = \"SHIELD\";\n    WearableType[WearableType[\"ONEHANDED_WEAPON\"] = 2] = \"ONEHANDED_WEAPON\";\n    WearableType[WearableType[\"TWOHANDED_WEAPON\"] = 3] = \"TWOHANDED_WEAPON\";\n})(WearableType = exports.WearableType || (exports.WearableType = {}));\nclass Wearable {\n    constructor(itemType) {\n        this.type = itemType;\n    }\n    applyTo(actor) {\n        (0, utils_1.ensure)(actor);\n        console.log(\"apply to:\" + actor.name);\n        /*\n        //jos pelaajalla on jo tmminen esine pll, riisutaan sen ensin.\n        //laitetaan tm esine pelaajan plle\n    \n        const unwielded = actor.destructible.wielded.unwield(this.type);\n        if (actor.container?.add(unwielded)) {\n          console.log(`Unwielding ${unwielded.name}`);\n          return true;\n        } else {\n          console.log(`Inventory is full.`);\n        }\n        */\n        return false;\n    }\n}\nexports.Wearable = Wearable;\nclass HealthEffect {\n    constructor(amount, message) {\n        this.amount = 0;\n        //super();\n        this.amount = amount;\n        this.message = message;\n    }\n    applyTo(actor) {\n        if (!actor || !actor.destructible)\n            return false;\n        if (this.amount > 0) {\n            //healing part\n            const pointsHealed = actor.destructible.heal(this.amount);\n            if (pointsHealed > 0) {\n                if (this.message) {\n                    _1.game.log.add(this.message, colors_1.Colors.HEALED);\n                }\n                return true;\n            }\n        }\n        else {\n            //hurting part\n            if (this.message && -this.amount - actor.destructible.defense > 0) {\n                _1.game.log.add(this.message);\n            }\n            if (actor.destructible.takeDamage(actor, -this.amount) > 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexports.HealthEffect = HealthEffect;\nclass AiChangeEffect {\n    constructor(newAi, message) {\n        //super();\n        this.message = message;\n        this.newAi = newAi;\n    }\n    applyTo(actor) {\n        this.newAi.applyTo(actor);\n        if (this.message) {\n            _1.game.log.add(this.message);\n        }\n        return true;\n    }\n}\nexports.AiChangeEffect = AiChangeEffect;\nclass Pickable {\n    constructor(props) {\n        this.selector = props === null || props === void 0 ? void 0 : props.selector;\n        this.effect = props === null || props === void 0 ? void 0 : props.effect;\n        this.weight = props === null || props === void 0 ? void 0 : props.weight;\n        if (this.selector !== undefined) {\n            this.selectorName = this.selector.constructor.name;\n        }\n        if (this.effect !== undefined)\n            this.effectName = this.effect.constructor.name;\n    }\n    pick(owner, wearer) {\n        if (wearer.container && wearer.container.add(owner)) {\n            _1.game.removeActor(owner);\n            return true;\n        }\n        return false;\n    }\n    use(owner, wearer) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            _1.game.log.add(`You use a ${owner.name}`);\n            const actorList = Array();\n            if (this.selector) {\n                yield this.selector.selectTargets(wearer, actorList);\n            }\n            else {\n                actorList.push(wearer);\n            }\n            let succeed = false;\n            for (const actor of actorList) {\n                if ((_a = this.effect) === null || _a === void 0 ? void 0 : _a.applyTo(actor)) {\n                    succeed = true;\n                }\n            }\n            if (succeed) {\n                if (wearer.container) {\n                    wearer.container.remove(owner);\n                }\n            }\n            return succeed;\n        });\n    }\n    drop(owner, wearer) {\n        if (wearer.container) {\n            wearer.container.remove(owner);\n            _1.game.actors.push(owner);\n            _1.game.sendToBack(owner);\n            owner.x = wearer.x;\n            owner.y = wearer.y;\n            _1.game.log.add(`${wearer.name} drops a ${owner.name}`);\n        }\n    }\n    wear(owner, wearer) {\n        if ((owner.armor || owner.weapon) &&\n            wearer.container &&\n            wearer.equipments &&\n            owner.pickable) {\n            //first, remove item from inventory (make space)\n            wearer.container.remove(owner);\n            const takeOff = wearer.equipments.takeOff(owner.pickable.effect.type);\n            //then, take off wielded item\n            //and add it to inventory\n            if (wearer.container && takeOff) {\n                _1.game.log.add(`take off a ${takeOff.name}`);\n                wearer.container.add(takeOff);\n            }\n            //and finally, add item to equipments\n            wearer.equipments.add(owner);\n            _1.game.log.add(`${wearer.name} wear a ${owner.name}`);\n            wearer.equipments.update(wearer);\n        }\n    }\n}\nexports[\"default\"] = Pickable;\n\n\n//# sourceURL=webpack://slanrl/./src/items/pickable.ts?");

/***/ }),

/***/ "./src/map/bsp_generator.ts":
/*!**********************************!*\
  !*** ./src/map/bsp_generator.ts ***!
  \**********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst random_1 = __importDefault(__webpack_require__(/*! ../utils/random */ \"./src/utils/random.ts\"));\nconst rectangle_1 = __importDefault(__webpack_require__(/*! ../utils/rectangle */ \"./src/utils/rectangle.ts\"));\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nconst bsp_node_1 = __importDefault(__webpack_require__(/*! ./bsp_node */ \"./src/map/bsp_node.ts\"));\nconst random = new random_1.default();\nclass bspGenerator {\n    constructor(x, y, w, h, maxLevel = 5) {\n        this.maxLevel = maxLevel;\n        this.rootContainer = new rectangle_1.default(x + 1, y + 1, w - 2, h - 2);\n        this.rows = h;\n        this.cols = w;\n        this.map = [];\n        this.doorPlaces = [];\n        this.tempRooms = [];\n        for (let h = 0; h < this.rows; h++) {\n            for (let w = 0; w < this.cols; w++) {\n                const index = this.cols * h + w;\n                this.map[index] = 1;\n            }\n        }\n        this.tree = this.Devide(this.rootContainer, 0);\n        this.rooms = this.tree.GetLeafs();\n        this.CreateRooms();\n        this.ConnectRooms(this.tree);\n    }\n    RandomSplit(container) {\n        let r1, r2;\n        let splitVertical = random.getInt(0, 1) ? false : true;\n        if (container.w > container.h && container.w / container.h >= 0.05) {\n            splitVertical = true;\n        }\n        else {\n            splitVertical = false;\n        }\n        if (splitVertical) {\n            //Vertical\n            const w = random.getInt(container.w * 0.3, container.w * 0.6);\n            r1 = new rectangle_1.default(container.x, container.y, w, container.h);\n            r2 = new rectangle_1.default(container.x + w, container.y, container.w - w, container.h);\n        }\n        else {\n            //horizontal\n            const h = random.getInt(container.h * 0.3, container.h * 0.6);\n            r1 = new rectangle_1.default(container.x, container.y, container.w, h);\n            r2 = new rectangle_1.default(container.x, container.y + h, container.w, container.h - h);\n        }\n        return [r1, r2];\n    }\n    Devide(container, level) {\n        const root = new bsp_node_1.default(container);\n        if (level < this.maxLevel) {\n            const sr = this.RandomSplit(container);\n            root.A = this.Devide(sr[0], level + 1);\n            root.B = this.Devide(sr[1], level + 1);\n        }\n        return root;\n    }\n    CreateRooms() {\n        //for (let i = 0; i < this.rooms.length; i++) {\n        for (const room of this.rooms) {\n            const w = random.getInt(room.w * 0.5, room.w * 0.9);\n            const h = random.getInt(room.h * 0.5, room.h * 0.9);\n            const x = random.getInt(room.x, room.x + room.w - w);\n            const y = random.getInt(room.y, room.y + room.h - h);\n            const rect = new rectangle_1.default(x, y, x + w, y + h);\n            this.tempRooms.push(rect);\n            for (let hi = y; hi < y + h; hi++) {\n                for (let wi = x; wi < x + w; wi++) {\n                    const index = this.cols * hi + wi;\n                    this.map[index] = 0;\n                }\n            }\n        }\n    }\n    IsThereRoom(x, y) {\n        for (const room of this.tempRooms) {\n            if (x >= room.x && y >= room.y && x <= room.w && y <= room.h) {\n                return true;\n            }\n        }\n        return false;\n    }\n    ConnectRooms(node) {\n        if (!node.A || !node.B) {\n            return false;\n        }\n        const x1 = (0, utils_1.float2int)(node.A.leaf.GetCenterX());\n        const y1 = (0, utils_1.float2int)(node.A.leaf.GetCenterY());\n        const x2 = (0, utils_1.float2int)(node.B.leaf.GetCenterX());\n        const y2 = (0, utils_1.float2int)(node.B.leaf.GetCenterY());\n        let doorsCreated = false;\n        let lastWasInRoom = false;\n        for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {\n            const index = this.cols * Math.max(y1, y2) + x;\n            this.map[index] = 0;\n            if (!doorsCreated && this.IsThereRoom(x, Math.max(y1, y2)) === true) {\n                lastWasInRoom = true;\n            }\n            else if (!doorsCreated &&\n                this.IsThereRoom(x, Math.max(y1, y2)) === false) {\n                if (lastWasInRoom === true) {\n                    doorsCreated = true;\n                    const re = new rectangle_1.default(x, Math.max(y1, y2), 0, 0);\n                    this.doorPlaces.push(re);\n                }\n            }\n        }\n        doorsCreated = false;\n        for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {\n            const index = this.cols * y + Math.max(x1, x2);\n            this.map[index] = 0;\n            if (!doorsCreated && this.IsThereRoom(Math.max(x1, x2), y) === true) {\n                lastWasInRoom = true;\n            }\n            else if (!doorsCreated &&\n                this.IsThereRoom(Math.max(x1, x2), y) === false) {\n                if (lastWasInRoom === true) {\n                    doorsCreated = true;\n                    const re = new rectangle_1.default(Math.max(x1, x2), y, 0, 0);\n                    this.doorPlaces.push(re);\n                }\n            }\n        }\n        this.ConnectRooms((0, utils_1.ensure)(node.A));\n        this.ConnectRooms((0, utils_1.ensure)(node.B));\n    }\n}\nexports[\"default\"] = bspGenerator;\n\n\n//# sourceURL=webpack://slanrl/./src/map/bsp_generator.ts?");

/***/ }),

/***/ "./src/map/bsp_node.ts":
/*!*****************************!*\
  !*** ./src/map/bsp_node.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst rectangle_1 = __importDefault(__webpack_require__(/*! ../utils/rectangle */ \"./src/utils/rectangle.ts\"));\nclass bspNode extends rectangle_1.default {\n    constructor(leaf) {\n        super(leaf.x, leaf.y, leaf.w, leaf.h);\n        this.A = undefined;\n        this.B = undefined;\n        this.leaf = leaf;\n    }\n    GetLeafs() {\n        if (!this.A || !this.B) {\n            return [this.leaf];\n        }\n        else {\n            return [...this.A.GetLeafs(), ...this.B.GetLeafs()];\n        }\n    }\n}\nexports[\"default\"] = bspNode;\n\n\n//# sourceURL=webpack://slanrl/./src/map/bsp_node.ts?");

/***/ }),

/***/ "./src/map/camera.ts":
/*!***************************!*\
  !*** ./src/map/camera.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Camera = void 0;\nclass Camera {\n    constructor() {\n        this.centerX = 0;\n        this.centerY = 0;\n        this.x = 0;\n        this.y = 0;\n    }\n    setCenter(w, h) {\n        this.centerX = w / 2;\n        this.centerY = h / 2;\n    }\n    compute(targetX, targetY) {\n        this.x = this.centerX - targetX;\n        this.y = this.centerY - targetY;\n    }\n}\nexports.Camera = Camera;\n\n\n//# sourceURL=webpack://slanrl/./src/map/camera.ts?");

/***/ }),

/***/ "./src/map/fov.ts":
/*!************************!*\
  !*** ./src/map/fov.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nclass Fov {\n    constructor(w, h) {\n        this.width = w;\n        this.height = h;\n        this.mapped = new Array(this.width * this.height).fill(0);\n    }\n    clear() {\n        for (let i = 0; i < this.width * this.height; i++) {\n            if (this.mapped[i] === 2) {\n                this.mapped[i] = 1;\n            }\n        }\n    }\n    fullClear() {\n        this.mapped = new Array(this.width * this.height).fill(0);\n    }\n    showAll() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        this.mapped = new Array(this.width * this.height).fill(2);\n        for (let y = 1; y < this.height - 1; y++) {\n            for (let x = 1; x < this.width - 1; x++) {\n                if (((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.isWall(x, y)) == true) {\n                    let walls = 0;\n                    if ((_b = _1.game.map) === null || _b === void 0 ? void 0 : _b.isWall(x - 1, y))\n                        walls++;\n                    if ((_c = _1.game.map) === null || _c === void 0 ? void 0 : _c.isWall(x + 1, y))\n                        walls++;\n                    if ((_d = _1.game.map) === null || _d === void 0 ? void 0 : _d.isWall(x, y - 1))\n                        walls++;\n                    if ((_e = _1.game.map) === null || _e === void 0 ? void 0 : _e.isWall(x, y + 1))\n                        walls++;\n                    if ((_f = _1.game.map) === null || _f === void 0 ? void 0 : _f.isWall(x - 1, y + 1))\n                        walls++;\n                    if ((_g = _1.game.map) === null || _g === void 0 ? void 0 : _g.isWall(x + 1, y + 1))\n                        walls++;\n                    if ((_h = _1.game.map) === null || _h === void 0 ? void 0 : _h.isWall(x - 1, y - 1))\n                        walls++;\n                    if ((_j = _1.game.map) === null || _j === void 0 ? void 0 : _j.isWall(x + 1, y - 1))\n                        walls++;\n                    if (walls >= 8) {\n                        const id = (0, utils_1.float2int)(x) + (0, utils_1.float2int)(y) * this.width;\n                        this.mapped[id] = 0;\n                    }\n                }\n            }\n        }\n    }\n    /* Just a placeholder */\n    compute(x, y, len) {\n        var _a;\n        this.clear();\n        let dx = 0;\n        let dy = 0;\n        let px = 0;\n        let py = 0;\n        this.mapped[x + y * this.width] = 2;\n        for (let a = 0; a < 360; a++) {\n            dx = Math.sin((a / 3.1415) * 180.0);\n            dy = Math.cos((a / 3.1415) * 180.0);\n            px = x + 0.5;\n            py = y + 0.5;\n            for (let l = 0; l < len; l++) {\n                px += dx;\n                py += dy;\n                if (px <= 0 || px >= this.width || py <= 0 || py >= this.height) {\n                    break;\n                }\n                const id = (0, utils_1.float2int)(px) + (0, utils_1.float2int)(py) * this.width;\n                this.mapped[id] = 2;\n                if (!((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk((0, utils_1.float2int)(px), (0, utils_1.float2int)(py)))) {\n                    break;\n                }\n            }\n        }\n    }\n    getMapped(x, y) {\n        if (x >= 0 && y >= 0 && x < this.width && y < this.height)\n            return this.mapped[x + y * this.width];\n        else\n            return 2;\n    }\n    isInFov(x, y) {\n        if (x >= 0 && y >= 0 && x < this.width && y < this.height) {\n            return this.mapped[x + y * this.width] > 0;\n        }\n        return false;\n    }\n}\nexports[\"default\"] = Fov;\n\n\n//# sourceURL=webpack://slanrl/./src/map/fov.ts?");

/***/ }),

/***/ "./src/map/map.ts":
/*!************************!*\
  !*** ./src/map/map.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.random = void 0;\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst itemGenerator_1 = __webpack_require__(/*! ../items/itemGenerator */ \"./src/items/itemGenerator.ts\");\nconst monsterGenerator_1 = __webpack_require__(/*! ../rpg/monsterGenerator */ \"./src/rpg/monsterGenerator.ts\");\nconst actor_1 = __importDefault(__webpack_require__(/*! ../units/actor */ \"./src/units/actor.ts\"));\nconst colors_1 = __webpack_require__(/*! ../utils/colors */ \"./src/utils/colors.ts\");\nconst random_1 = __importDefault(__webpack_require__(/*! ../utils/random */ \"./src/utils/random.ts\"));\nconst rectangle_1 = __importDefault(__webpack_require__(/*! ../utils/rectangle */ \"./src/utils/rectangle.ts\"));\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nconst bsp_generator_1 = __importDefault(__webpack_require__(/*! ./bsp_generator */ \"./src/map/bsp_generator.ts\"));\nexports.random = new random_1.default();\nclass Tile {\n    constructor() {\n        this.canWalk = false;\n        this.explored = false;\n    }\n}\nclass Map {\n    constructor(width, height) {\n        this.startX = 0;\n        this.startY = 0;\n        this.stairsX = 0;\n        this.stairsY = 0;\n        this.levelSeed = 0;\n        this.depth = 0;\n        this.ROOM_MAX_SIZE = 5;\n        this.ROOM_MIN_SIZE = 4;\n        this.MAX_ROOM_MONSTERS = 3;\n        this.MAX_ROOM_ITEMS = 2;\n        this.width = width;\n        this.height = height;\n        this.templateDoors = [];\n        this.tiles = new Array(this.width * this.height).fill(false);\n    }\n    save() {\n        window.localStorage.setItem(\"seed\", this.levelSeed.toString());\n        window.localStorage.setItem(\"depth\", this.depth.toString());\n    }\n    isWall(x, y) {\n        const index = x + y * this.width;\n        return !this.tiles[index].canWalk;\n    }\n    setWall(x, y) {\n        this.tiles[x + y * this.width].canWalk = false;\n    }\n    canWalk(x, y) {\n        if (this.isWall(x, y))\n            return false;\n        for (const actor of _1.game.actors) {\n            if (actor.x === x && actor.y === y && actor.blocks) {\n                return false;\n            }\n        }\n        return true;\n    }\n    addMonster(x, y) {\n        const monsterListSmall = [\n            \"bat\",\n            \"rat\",\n            \"jackal\",\n            \"lizard\",\n            \"kobold\",\n            \"giant rat\",\n        ];\n        const monsterListBig = [\"giant rat\", \"orc\", \"ghoul\"];\n        if (exports.random.getInt(0, 100) > 20) {\n            const rng = exports.random.getInt(0, monsterListSmall.length);\n            _1.game.actors.push((0, monsterGenerator_1.createMonster)(monsterListSmall[rng], x, y));\n        }\n        else {\n            const rng = exports.random.getInt(0, monsterListBig.length);\n            _1.game.actors.push((0, monsterGenerator_1.createMonster)(monsterListBig[rng], x, y));\n        }\n        /*\n        if (rng < 60) {\n          game.actors.push(createMonster(\"orc\", x, y));\n        } else if (rng < 60 + 10) {\n          game.actors.push(createMonster(\"troll\", x, y));\n        } else {\n          game.actors.push(createMonster(\"rat\", x, y));\n        }\n        */\n    }\n    openCloseDoor(x, y) {\n        const actor = _1.game.getAnyActor(x, y);\n        if (actor && actor.name === \"door\") {\n            actor.blocks = !actor.blocks;\n            if (actor.blocks) {\n                actor.ch = \"D\";\n                _1.game.log.add(\"a door is closed\");\n            }\n            else {\n                actor.ch = \"+\";\n                _1.game.log.add(\"a door is opened\");\n            }\n            return true;\n        }\n        return false;\n    }\n    addDoor(x, y, closed) {\n        const door = new actor_1.default(x, y, closed ? \"D\" : \"+\", \"door\", colors_1.Colors.DOOR);\n        door.blocks = true;\n        //door.destructible = new Destructible(100, 0, \"broken door\", \"door\", 0);\n        //add door, if its between walls\n        if ((this.isWall(x - 1, y) == true && this.isWall(x + 1, y) == true) ||\n            (this.isWall(x, y - 1) == true && this.isWall(x, y + 1) == true))\n            _1.game.actors.push(door);\n    }\n    additem(x, y) {\n        const rng = exports.random.getInt(0, 100);\n        let item;\n        if (rng < 70) {\n            if (exports.random.getInt(0, 100) < 95) {\n                item = (0, itemGenerator_1.createItem)({ name: \"health potion\", x, y });\n            }\n            else {\n                item = (0, itemGenerator_1.createItem)({ name: \"nutella bun\", x, y });\n                console.log(\"Jossain haisoo nutella!\");\n            }\n        }\n        else if (rng < 70 + 10) {\n            item = (0, itemGenerator_1.createItem)({ name: \"scroll of lighting bolt\", x, y });\n        }\n        else if (rng < 70 + 20) {\n            item = (0, itemGenerator_1.createItem)({ name: \"scroll of fireball\", x, y });\n        }\n        else if (rng < 70 + 25) {\n            item = (0, itemGenerator_1.createItem)({ name: \"scroll of confusion\", x, y });\n        }\n        else {\n            item = (0, itemGenerator_1.createItem)({ name: \"scroll of map\", x, y });\n        }\n        if (item) {\n            _1.game.actors.push(item);\n            _1.game.sendToBack(item);\n        }\n    }\n    dig(x1, y1, x2, y2, withActors) {\n        x1 = (0, utils_1.float2int)(x1);\n        x2 = (0, utils_1.float2int)(x2);\n        y1 = (0, utils_1.float2int)(y1);\n        y2 = (0, utils_1.float2int)(y2);\n        if (x2 < x1) {\n            const tmp = x2;\n            x2 = x1;\n            x1 = tmp;\n        }\n        if (y2 < y1) {\n            const tmp = y2;\n            y2 = y1;\n            y1 = tmp;\n        }\n        let lastWalkable = false;\n        for (let tilex = x1; tilex <= x2; tilex++) {\n            for (let tiley = y1; tiley <= y2; tiley++) {\n                const index = tilex + tiley * this.width;\n                if (this.tiles[index].canWalk == false &&\n                    lastWalkable === true &&\n                    (x1 === x2 || y1 === y2)) {\n                    if (withActors && tilex !== this.stairsX && tiley !== this.stairsY) {\n                        this.templateDoors.push(new rectangle_1.default(tilex, tiley, 0, 0));\n                    }\n                }\n                lastWalkable = this.tiles[index].canWalk;\n                this.tiles[index].canWalk = true;\n            }\n        }\n    }\n    addActors(room) {\n        let numberOfMonsters = exports.random.getInt(0, this.MAX_ROOM_MONSTERS);\n        let numberOfItems = exports.random.getInt(0, this.MAX_ROOM_ITEMS);\n        //console.log(room);\n        const x1 = room.x;\n        const x2 = room.x + room.w;\n        const y1 = room.y;\n        const y2 = room.y + room.h;\n        while (numberOfMonsters > 0) {\n            const x = exports.random.getInt(x1, x2);\n            const y = exports.random.getInt(y1, y2);\n            if (this.canWalk(x, y)) {\n                this.addMonster(x, y);\n            }\n            numberOfMonsters--;\n        }\n        while (numberOfItems > 0) {\n            const x = exports.random.getInt(x1, x2);\n            const y = exports.random.getInt(y1, y2);\n            if (this.canWalk(x, y)) {\n                this.additem(x, y);\n            }\n            numberOfItems--;\n        }\n    }\n    createRoom(x1, y1, x2, y2, withActors) {\n        this.dig(x1, y1, x2, y2, withActors);\n        /*\n        this.stairsX = ((x1 + x2) / 2) | 0;\n        this.stairsY = ((y1 + y2) / 2) | 0;\n        \n        \n        this.startX = this.stairsX;\n        this.startY = this.stairsY;\n        */\n    }\n    generate(withActors, seed, depth) {\n        this.levelSeed = seed;\n        this.depth = depth;\n        exports.random.setSeed(this.levelSeed + depth * 25);\n        const maxSplitLevel = exports.random.getInt(4, 8);\n        console.log(\"seed: \" + this.levelSeed);\n        console.log(\"depth: \" + this.depth);\n        console.log(\"split level:\" + maxSplitLevel);\n        const root = new bsp_generator_1.default(0, 0, this.width, this.height, maxSplitLevel);\n        this.tiles = new Array(this.width * this.height).fill(false);\n        const monsterRooms = [];\n        //const option = random.getInt(0, 2);\n        //console.log(\"option: \" + option);\n        const option = exports.random.getInt(0, 100) > 70 ? 1 : 2;\n        for (let i = 0; i < this.width * this.height; i++) {\n            this.tiles[i] = new Tile();\n            //we can use path/room data directly from bsp if we want.\n            //if (option === 0) this.tiles[i].canWalk = !this.root.map[i];\n        }\n        //lets create every room one by one\n        let lastx = 0;\n        let lasty = 0;\n        let x = 0;\n        let y = 0;\n        let w = 0;\n        let h = 0;\n        //take one room and make it spawn room\n        const spawnRoomIndex = exports.random.getInt(0, root.rooms.length - 1);\n        const stairsRoomIndex = exports.random.getInt(0, root.rooms.length - 1);\n        /*\n        console.log(\n          \"spwanroom index: \" + spawnRoomIndex + \" / \" + (root.rooms.length - 1),\n        );\n        */\n        for (let i = 0; i < root.rooms.length; i++) {\n            const room = root.rooms[i];\n            const spawnRoom = i === spawnRoomIndex ? true : false;\n            //option 1\n            if (option === 1) {\n                w = room.w;\n                h = room.h;\n                x = room.x + 1;\n                y = room.y + 1;\n                this.createRoom(x, y, x + w - 2, y + h - 2, withActors);\n                if (!spawnRoom)\n                    monsterRooms.push(new rectangle_1.default(x, y, w - 2, h - 2));\n            }\n            //option 2\n            if (option === 2) {\n                w = exports.random.getInt(this.ROOM_MIN_SIZE, room.w - 2);\n                h = exports.random.getInt(this.ROOM_MIN_SIZE, room.h - 2);\n                x = exports.random.getInt(room.x, room.x + room.w - w - 0) + 1;\n                y = exports.random.getInt(room.y, room.y + room.h - h - 0) + 1;\n                this.createRoom(x, y, x + w - 2, y + h - 2, withActors);\n                if (!spawnRoom)\n                    monsterRooms.push(new rectangle_1.default(x, y, w - 2, h - 2));\n            }\n            if (i === spawnRoomIndex) {\n                this.startX = x + (0, utils_1.float2int)(w / 2);\n                this.startY = y + (0, utils_1.float2int)(h / 2);\n            }\n            if (i === stairsRoomIndex) {\n                this.stairsX = (0, utils_1.float2int)(x + w / 2);\n                this.stairsY = (0, utils_1.float2int)(y + h / 2);\n            }\n            if (option === 1 || option === 2) {\n                if (i > 0) {\n                    this.dig(lastx, lasty, x + w / 2, lasty, withActors);\n                    this.dig(x + w / 2, lasty, x + w / 2, y + h / 2, withActors);\n                }\n                lastx = x + w / 2;\n                lasty = y + h / 2;\n            }\n        }\n        if (withActors) {\n            for (const room of monsterRooms) {\n                this.addActors(room);\n            }\n            for (const door of this.templateDoors) {\n                this.addDoor(door.x, door.y, true);\n            }\n        }\n    }\n    render() {\n        var _a, _b;\n        const darkWall = \"#\";\n        const darkGround = \".\";\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const fovValue = (_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.getMapped(x, y);\n                const cx = x + _1.game.camera.x;\n                const cy = y + _1.game.camera.y;\n                if (fovValue === 2 || fovValue === 1) {\n                    if (fovValue === 2) {\n                        _1.game.drawChar(this.isWall(x, y) ? darkWall : darkGround, cx, cy, colors_1.Colors.WALL);\n                    }\n                    else {\n                        _1.game.drawChar(this.isWall(x, y) ? darkWall : darkGround, cx, cy, colors_1.Colors.WALL_DARK);\n                    }\n                }\n            }\n        }\n    }\n}\nexports[\"default\"] = Map;\n\n\n//# sourceURL=webpack://slanrl/./src/map/map.ts?");

/***/ }),

/***/ "./src/rpg/abilities.ts":
/*!******************************!*\
  !*** ./src/rpg/abilities.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Abilities = exports.ABILITIES = void 0;\nvar ABILITIES;\n(function (ABILITIES) {\n    ABILITIES[ABILITIES[\"STR\"] = 0] = \"STR\";\n    ABILITIES[ABILITIES[\"DEX\"] = 1] = \"DEX\";\n    ABILITIES[ABILITIES[\"CON\"] = 2] = \"CON\";\n    ABILITIES[ABILITIES[\"INT\"] = 3] = \"INT\";\n    ABILITIES[ABILITIES[\"WIS\"] = 4] = \"WIS\";\n})(ABILITIES = exports.ABILITIES || (exports.ABILITIES = {}));\nclass Abilities {\n    constructor(str, dex, con, int, wis) {\n        this.str = 0;\n        this.dex = 0;\n        this.con = 0;\n        this.int = 0;\n        this.wis = 0;\n        this.str = str;\n        this.dex = dex;\n        this.con = con;\n        this.int = int;\n        this.wis = wis;\n    }\n    getBonus(type) {\n        let val = 0;\n        switch (type) {\n            case ABILITIES.STR:\n                val = this.str;\n                break;\n            case ABILITIES.DEX:\n                val = this.dex;\n                break;\n            case ABILITIES.CON:\n                val = this.con;\n                break;\n            case ABILITIES.INT:\n                val = this.int;\n                break;\n            case ABILITIES.WIS:\n                val = this.wis;\n                break;\n            default:\n                break;\n        }\n        return Math.floor((val - 10) / 2);\n    }\n    getBonusWithSign(type) {\n        const val = this.getBonus(type);\n        return (val >= 0 ? \"+\" : \"\") + val.toString();\n    }\n}\nexports.Abilities = Abilities;\n\n\n//# sourceURL=webpack://slanrl/./src/rpg/abilities.ts?");

/***/ }),

/***/ "./src/rpg/armor.ts":
/*!**************************!*\
  !*** ./src/rpg/armor.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ArmorType = void 0;\nvar ArmorType;\n(function (ArmorType) {\n    ArmorType[ArmorType[\"LIGHT_ARMOR\"] = 0] = \"LIGHT_ARMOR\";\n    ArmorType[ArmorType[\"MEDIUM_ARMOR\"] = 1] = \"MEDIUM_ARMOR\";\n    ArmorType[ArmorType[\"HEAVY_ARMOR\"] = 2] = \"HEAVY_ARMOR\";\n    ArmorType[ArmorType[\"SHIELD\"] = 3] = \"SHIELD\";\n})(ArmorType = exports.ArmorType || (exports.ArmorType = {}));\nclass Armor {\n    constructor(props) {\n        this.name = props.name;\n        this.armorClass = props.ac;\n        this.armorClassAbilityType = props.armorClassAbilityType;\n        this.armorType = props.armorType;\n        this.armorRequirementStrenght = props === null || props === void 0 ? void 0 : props.requirementStrenght;\n    }\n}\nexports[\"default\"] = Armor;\n\n\n//# sourceURL=webpack://slanrl/./src/rpg/armor.ts?");

/***/ }),

/***/ "./src/rpg/attacker.ts":
/*!*****************************!*\
  !*** ./src/rpg/attacker.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst ai_1 = __webpack_require__(/*! ../units/ai */ \"./src/units/ai.ts\");\nconst colors_1 = __webpack_require__(/*! ../utils/colors */ \"./src/utils/colors.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nconst abilities_1 = __webpack_require__(/*! ./abilities */ \"./src/rpg/abilities.ts\");\nclass Attacker {\n    constructor(power) {\n        this.power = power;\n    }\n    attack(owner, target) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.meleeAttack(owner, target);\n        });\n    }\n    meleeAttack(owner, target) {\n        if (target.destructible && !target.destructible.isDead()) {\n            //check if damage roll is succesful\n            //its just calculated hit or miss\n            const hitOrMiss = ai_1.random.dice(1, 20, 0);\n            const attackModifier = (0, utils_1.ensure)(owner.abilities).getBonus(abilities_1.ABILITIES.STR);\n            let bonus = false;\n            if (hitOrMiss === 1) {\n                _1.game.log.add(`${target.name} miss attack by ${owner.name}`);\n                return;\n            }\n            if (hitOrMiss === 20) {\n                bonus = true;\n                _1.game.log.add(`${owner.name} makes critical attack to ${target.name}!`, colors_1.Colors.HILIGHT_TEXT);\n            }\n            if (hitOrMiss >= target.destructible.defense) {\n                const [numberOfDices, numberOfEyes] = this.power.split(\"d\");\n                let dices = 1;\n                const diceDmg = ai_1.random.dice(bonus === true\n                    ? (dices = parseInt(numberOfDices) * 2)\n                    : (dices = parseInt(numberOfDices)), parseInt(numberOfEyes), 0);\n                const eyes = numberOfEyes;\n                _1.game.log.add(`${owner.name} attacks ${target.name} for ${diceDmg} hit points (${dices}d${eyes}${attackModifier > 0 ? \"+\" : \"-\"}${Math.abs(attackModifier)}).`, owner === _1.game.player ? colors_1.Colors.PLAYER_ATTACK : colors_1.Colors.ENEMY_ATTACK);\n                let finalDamage = diceDmg + attackModifier;\n                if (finalDamage < 0)\n                    finalDamage = 0;\n                target.destructible.takeDamage(target, finalDamage);\n            }\n        }\n    }\n}\nexports[\"default\"] = Attacker;\n\n\n//# sourceURL=webpack://slanrl/./src/rpg/attacker.ts?");

/***/ }),

/***/ "./src/rpg/monsterGenerator.ts":
/*!*************************************!*\
  !*** ./src/rpg/monsterGenerator.ts ***!
  \*************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createMonster = exports.monsters = void 0;\nconst monsters_json_1 = __importDefault(__webpack_require__(/*! ../data/monsters.json */ \"./src/data/monsters.json\"));\nconst actor_1 = __importDefault(__webpack_require__(/*! ../units/actor */ \"./src/units/actor.ts\"));\nconst ai_1 = __webpack_require__(/*! ../units/ai */ \"./src/units/ai.ts\");\nconst destructible_1 = __webpack_require__(/*! ../units/destructible */ \"./src/units/destructible.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nconst abilities_1 = __webpack_require__(/*! ./abilities */ \"./src/rpg/abilities.ts\");\nconst attacker_1 = __importDefault(__webpack_require__(/*! ./attacker */ \"./src/rpg/attacker.ts\"));\nexports.monsters = monsters_json_1.default;\nconst getMonsterUsingFind = (name) => {\n    return exports.monsters.find(item => item.name === name);\n};\nconst createMonster = (name, x, y) => {\n    let power = \"1d4\";\n    let xp = 0;\n    let hp = 1;\n    let defense = 0;\n    let ch = \"?\";\n    let color = \"#F0F\";\n    let abi = new abilities_1.Abilities(2, 2, 2, 2, 2);\n    const isMonster = (name) => {\n        for (const n of exports.monsters) {\n            if (n.name === name)\n                return true;\n        }\n        return false;\n    };\n    /*\n      List of enemies (candidates)\n      very Easy:\n        name,       depth:(1 - 5)\n        rat,\n        kobold,\n        dog,\n        cat,\n        roach,\n        turtle,\n        jackal\n      easy:         depth: (3 - 10)\n        hobgoblin,\n        imp,\n        jelly,\n        ooze,\n        lich,\n        lizard,\n        bat,\n        goblin\n      Medium:       depth: (8 - 15)\n        bear,\n        wolf,\n        golem,\n        insect,\n        mummy,\n        scorpion,\n        orc,\n        troll\n      Hard:         depth: (12 - 20)\n        elemental,\n        skeleton,\n        zombie,\n        lizardman,\n        demon\n    */\n    /*\n      Size of enemies:\n      tiny, small, medium, lardge, huge\n    */\n    //enemytypes:\n    /*\n      beasts,\n      dragons,\n      elementals,\n      giants,\n      humanoids,\n      monstrosities,\n      oozes,\n      plants,\n      undead,\n    */\n    if (isMonster(name)) {\n        const monsterTemplate = (0, utils_1.ensure)(getMonsterUsingFind(name));\n        ch = monsterTemplate.ch;\n        color = monsterTemplate.color;\n        power = monsterTemplate.attacks[0].damage;\n        defense = monsterTemplate.ac;\n        hp = monsterTemplate.hp;\n        xp = monsterTemplate.xp;\n        abi = new abilities_1.Abilities(monsterTemplate.abilities.str, monsterTemplate.abilities.dex, monsterTemplate.abilities.con, monsterTemplate.abilities.int, monsterTemplate.abilities.wis);\n    }\n    const monster = new actor_1.default(x, y, ch, name, color);\n    monster.destructible = new destructible_1.MonsterDestructible(hp, defense, `dead ${name}`, xp);\n    monster.attacker = new attacker_1.default(power);\n    monster.ai = new ai_1.MonsterAI();\n    monster.abilities = abi;\n    return monster;\n};\nexports.createMonster = createMonster;\n\n\n//# sourceURL=webpack://slanrl/./src/rpg/monsterGenerator.ts?");

/***/ }),

/***/ "./src/rpg/weapon.ts":
/*!***************************!*\
  !*** ./src/rpg/weapon.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DamageType = void 0;\nvar DamageType;\n(function (DamageType) {\n    DamageType[DamageType[\"BLUDGEONING\"] = 0] = \"BLUDGEONING\";\n    DamageType[DamageType[\"PIERCING\"] = 1] = \"PIERCING\";\n    DamageType[DamageType[\"SLASHING\"] = 2] = \"SLASHING\";\n})(DamageType = exports.DamageType || (exports.DamageType = {}));\nclass Weapon {\n    constructor(props) {\n        this.name = props.name;\n        this.damage = props.damage;\n        this.damageType = props.damageType;\n    }\n}\nexports[\"default\"] = Weapon;\n\n\n//# sourceURL=webpack://slanrl/./src/rpg/weapon.ts?");

/***/ }),

/***/ "./src/units/actor.ts":
/*!****************************!*\
  !*** ./src/units/actor.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst pickable_1 = __importStar(__webpack_require__(/*! ../items/pickable */ \"./src/items/pickable.ts\"));\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nconst ai_1 = __webpack_require__(/*! ./ai */ \"./src/units/ai.ts\");\nclass Actor {\n    constructor(x, y, ch, name, color) {\n        this.fovOnly = true;\n        this.blocks = true; //can we walk on this actor?\n        this.x = (0, utils_1.float2int)(x);\n        this.y = (0, utils_1.float2int)(y);\n        this.ch = ch;\n        this.color = color;\n        this.name = name;\n    }\n    create(actorTemplate) {\n        var _a, _b, _c, _d, _e, _f;\n        let fx = undefined;\n        if (((_a = actorTemplate.pickable) === null || _a === void 0 ? void 0 : _a.effectName) === \"Wearable\") {\n            fx = new pickable_1.Wearable(actorTemplate.pickable.effect.type);\n            //console.log(actorTemplate);\n        }\n        if (((_b = actorTemplate.pickable) === null || _b === void 0 ? void 0 : _b.effectName) === \"AiChangeEffect\") {\n            fx = new pickable_1.AiChangeEffect(new ai_1.ConfusedMonsterAi(parseInt(actorTemplate.pickable.effect.newAi.nbTurns)), actorTemplate.pickable.effect.message);\n        }\n        if (((_c = actorTemplate === null || actorTemplate === void 0 ? void 0 : actorTemplate.pickable) === null || _c === void 0 ? void 0 : _c.effectName) === \"HealthEffect\")\n            fx = new pickable_1.HealthEffect((_d = actorTemplate.pickable) === null || _d === void 0 ? void 0 : _d.effect.amount, undefined);\n        if ((_e = actorTemplate === null || actorTemplate === void 0 ? void 0 : actorTemplate.pickable) === null || _e === void 0 ? void 0 : _e.selectorName) {\n            //console.log(actorTemplate.pickable.selectorName);\n            this.pickable = new pickable_1.default({\n                selector: new pickable_1.TargetSelector((0, utils_1.ensure)(actorTemplate.pickable.selector).type, (0, utils_1.ensure)(actorTemplate.pickable.selector).range),\n                effect: fx,\n                weight: actorTemplate.pickable.weight,\n            });\n        }\n        else {\n            this.pickable = new pickable_1.default({\n                selector: undefined,\n                effect: fx,\n                weight: (0, utils_1.ensure)((_f = actorTemplate.pickable) === null || _f === void 0 ? void 0 : _f.weight),\n            });\n        }\n    }\n    render() {\n        var _a, _b;\n        const fovValue = (_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.getMapped(this.x, this.y);\n        if (fovValue === 2 || (fovValue != 0 && !this.fovOnly)) {\n            _1.game.drawChar(this.ch, this.x + _1.game.camera.x, this.y + _1.game.camera.y, this.color);\n        }\n    }\n    update() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.ai) {\n                yield this.ai.update(this);\n            }\n        });\n    }\n    computeFov() {\n        if (this.fov) {\n            this.fov.compute(this.x, this.y, 10);\n        }\n    }\n    getDistance(x, y) {\n        const dx = this.x - x;\n        const dy = this.y - y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}\nexports[\"default\"] = Actor;\n\n\n//# sourceURL=webpack://slanrl/./src/units/actor.ts?");

/***/ }),

/***/ "./src/units/ai.ts":
/*!*************************!*\
  !*** ./src/units/ai.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConfusedMonsterAi = exports.TemporaryAI = exports.ConfusedAI = exports.MonsterAI = exports.PlayerAI = exports.random = void 0;\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst colors_1 = __webpack_require__(/*! ../utils/colors */ \"./src/utils/colors.ts\");\nconst menu_1 = __webpack_require__(/*! ../utils/menu */ \"./src/utils/menu.ts\");\nconst random_1 = __importDefault(__webpack_require__(/*! ../utils/random */ \"./src/utils/random.ts\"));\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nexports.random = new random_1.default();\nclass AI {\n}\nexports[\"default\"] = AI;\nclass PlayerAI extends AI {\n    constructor() {\n        super();\n        this.xpLevel = 1;\n    }\n    getNextLevelXP() {\n        const LEVEL_UP_BASE = 200;\n        const LEVEL_UP_FACTOR = 150;\n        return LEVEL_UP_BASE + this.xpLevel * LEVEL_UP_FACTOR;\n    }\n    pickDirection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ch = yield _1.game.getch();\n            let dx = 0;\n            let dy = 0;\n            if (ch === \"ArrowLeft\") {\n                dx = -1;\n            }\n            if (ch === \"ArrowRight\") {\n                dx = 1;\n            }\n            if (ch === \"ArrowUp\") {\n                dy = -1;\n            }\n            if (ch === \"ArrowDown\") {\n                dy = 1;\n            }\n            return [dx, dy];\n        });\n    }\n    update(owner) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            const levelUpXp = this.getNextLevelXP();\n            if ((0, utils_1.ensure)(owner.destructible).xp >= levelUpXp) {\n                this.xpLevel++;\n                (0, utils_1.ensure)(owner.destructible).xp -= levelUpXp;\n                _1.game.log.add(`Your battle skills grow stronger! You reached level ${this.xpLevel}`, colors_1.Colors.LEVEL_UP);\n                _1.game.menu = new menu_1.Menu();\n                _1.game.menu.clear();\n                _1.game.menu.addItem(menu_1.MenuItemCode.CONSTITUTION, \"Constitution (+20 hp)\");\n                _1.game.menu.addItem(menu_1.MenuItemCode.STRENGTH, \"Strenght (+1 attack)\");\n                _1.game.menu.addItem(menu_1.MenuItemCode.AGILITY, \"Agility (+1 defense)\");\n                let cursor = 0;\n                let selectedItem = -1;\n                while (true) {\n                    _1.game.clear();\n                    _1.game.renderUI();\n                    _1.game.drawChar(\">\", _1.game.width / 2 - 12, 10 + cursor, colors_1.Colors.MENU_CURSOR);\n                    for (let i = 0; i < _1.game.menu.items.length; i++) {\n                        _1.game.drawText(_1.game.menu.items[i].label, _1.game.width / 2 - 10, 10 + i);\n                    }\n                    const ch = yield _1.game.getch();\n                    if (ch === \"ArrowDown\")\n                        cursor++;\n                    if (ch === \"ArrowUp\")\n                        cursor--;\n                    if (ch === \"Enter\") {\n                        selectedItem = _1.game.menu.items[cursor].code;\n                        break;\n                    }\n                    cursor = cursor % _1.game.menu.items.length;\n                    if (cursor < 0)\n                        cursor = _1.game.menu.items.length - 1;\n                }\n                if (selectedItem != -1) {\n                    if (selectedItem === menu_1.MenuItemCode.CONSTITUTION) {\n                        (0, utils_1.ensure)(owner.destructible).hp += 20;\n                        (0, utils_1.ensure)(owner.destructible).maxHP += 20;\n                    }\n                    if (selectedItem === menu_1.MenuItemCode.STRENGTH) {\n                        (0, utils_1.ensure)(owner.attacker).power += 1;\n                    }\n                    if (selectedItem === menu_1.MenuItemCode.AGILITY) {\n                        (0, utils_1.ensure)(owner.destructible).defense += 1;\n                    }\n                }\n                _1.game.render();\n            }\n            if (owner.destructible && owner.destructible.isDead())\n                return;\n            let dx = 0;\n            let dy = 0;\n            const ch = yield _1.game.getch();\n            switch (ch) {\n                case \"ArrowLeft\":\n                    dx--;\n                    break;\n                case \"ArrowRight\":\n                    dx++;\n                    break;\n                case \"ArrowUp\":\n                    dy--;\n                    break;\n                case \"ArrowDown\":\n                    dy++;\n                    break;\n                default:\n                    yield this.handleActionKey(owner, ch);\n                    break;\n            }\n            if (dx !== 0 || dy !== 0) {\n                _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                if (yield this.moveOrAttack(owner, owner.x + dx, owner.y + dy)) {\n                    (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.computeFov();\n                    _1.game.camera.compute((0, utils_1.ensure)((_b = _1.game.player) === null || _b === void 0 ? void 0 : _b.x), (0, utils_1.ensure)((_c = _1.game.player) === null || _c === void 0 ? void 0 : _c.y));\n                }\n            }\n        });\n    }\n    handleActionKey(owner, ascii) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                _1.game.log.add(\"Which direction?\");\n                _1.game.render();\n                const [dx, dy] = yield this.pickDirection();\n                if (!((_a = _1.game === null || _1.game === void 0 ? void 0 : _1.game.map) === null || _a === void 0 ? void 0 : _a.openCloseDoor(owner.x + dx, owner.y + dy))) {\n                    _1.game.log.add(\"There is no any door.\");\n                }\n                (_b = _1.game.player) === null || _b === void 0 ? void 0 : _b.computeFov();\n                _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n            });\n            const handleSave = () => __awaiter(this, void 0, void 0, function* () {\n                _1.game.save();\n                _1.game.log.add(\"Game saved...\", colors_1.Colors.GAME_SAVED);\n            });\n            const handleNextLevel = () => {\n                var _a, _b;\n                if (((_a = _1.game.stairs) === null || _a === void 0 ? void 0 : _a.x) === owner.x && ((_b = _1.game.stairs) === null || _b === void 0 ? void 0 : _b.y) === owner.y) {\n                    _1.game.nextLevel();\n                }\n                else {\n                    _1.game.log.add(\"There are no stairs here.\");\n                }\n            };\n            const handlePickup = () => {\n                _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                let found = false;\n                for (const actor of _1.game.actors) {\n                    if (actor.pickable && actor.x === owner.x && actor.y === owner.y) {\n                        if (actor.pickable.pick(actor, owner)) {\n                            found = true;\n                            _1.game.log.add(`You pick up the ${actor.name}`, colors_1.Colors.PICKED_UP);\n                            break;\n                        }\n                        else if (!found) {\n                            found = true;\n                            _1.game.log.add(\"Your inventory is full.\", colors_1.Colors.INVENTORY_FULL);\n                        }\n                    }\n                }\n                if (!found) {\n                    _1.game.log.add(\"There's nothing here that you can pick up.\");\n                }\n            };\n            const handleUseItem = () => __awaiter(this, void 0, void 0, function* () {\n                _1.game.log.add(\"Use item\");\n                const useItem = yield this.choseFromInventory(owner);\n                if (useItem) {\n                    yield (0, utils_1.ensure)(useItem.pickable).use(useItem, owner);\n                    _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                }\n                else {\n                    _1.game.log.add(\"Nevermind...\");\n                }\n            });\n            const handleDropItem = () => __awaiter(this, void 0, void 0, function* () {\n                const dropItem = yield this.choseFromInventory(owner);\n                if (dropItem) {\n                    yield (0, utils_1.ensure)(dropItem.pickable).drop(dropItem, owner);\n                    _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                }\n                else {\n                    _1.game.log.add(\"Nevermind...\");\n                }\n            });\n            const handleWield = () => __awaiter(this, void 0, void 0, function* () {\n                const wieldedItem = yield this.choseFromInventory(owner);\n                if (wieldedItem) {\n                    //game.log.add(`You wield up the ${wieldedItem.name}`, Colors.PICKED_UP);\n                    yield (0, utils_1.ensure)(wieldedItem.pickable).wear(wieldedItem, owner);\n                    _1.game.gameStatus = _1.GameStatus.NEW_TURN;\n                }\n                else {\n                    _1.game.log.add(\"Nevermind...\");\n                }\n            });\n            const handleFov = () => {\n                var _a, _b;\n                (_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.showAll();\n                _1.game.saveImage();\n            };\n            switch (ascii) {\n                case \"S\": //save\n                    handleSave();\n                    break;\n                case \">\": //go down\n                    handleNextLevel();\n                    break;\n                case \"g\": //pickup item\n                    handlePickup();\n                    break;\n                case \"i\": //use item\n                    yield handleUseItem();\n                    break;\n                case \"d\": //drop item\n                    yield handleDropItem();\n                    break;\n                case \"o\": //open\n                    yield handleOpen();\n                    break;\n                case \"w\": //wield\n                    yield handleWield();\n                    break;\n                case \"f\":\n                    handleFov();\n                    break;\n                default:\n                    break;\n            }\n        });\n    }\n    moveOrAttack(owner, targetX, targetY) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.isWall(targetX, targetY))\n                return false; //move\n            let doorFound = false;\n            for (const actor of _1.game.actors) {\n                if (actor.destructible &&\n                    !actor.destructible.isDead() &&\n                    actor.x === targetX &&\n                    actor.y === targetY) {\n                    yield (0, utils_1.ensure)(owner.attacker).attack(owner, actor);\n                    return false; //attack\n                }\n            }\n            //look for corpses or items\n            for (const actor of _1.game.actors) {\n                const corpseOrItem = (actor.destructible && actor.destructible.isDead) ||\n                    actor.pickable ||\n                    actor.name === \"door\";\n                if (corpseOrItem && actor.x === targetX && actor.y === targetY) {\n                    _1.game.log.add(`There is a ${actor.name} here`);\n                }\n                if (actor.name === \"door\" &&\n                    actor.blocks &&\n                    actor.x === targetX &&\n                    actor.y === targetY) {\n                    doorFound = true;\n                }\n            }\n            if (doorFound) {\n                return false;\n            }\n            owner.x = targetX;\n            owner.y = targetY;\n            return true;\n        });\n    }\n    choseFromInventory(owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            _1.game.clear();\n            _1.game.render();\n            if (owner.container)\n                owner.container.render();\n            const ch = yield _1.game.getch();\n            const actorIndex = ch.charCodeAt(0) - 97; //97 = a\n            if (actorIndex >= 0 &&\n                actorIndex < (0, utils_1.ensure)(owner.container).inventory.length) {\n                return (0, utils_1.ensure)(owner.container).inventory[actorIndex];\n            }\n            return null;\n        });\n    }\n}\nexports.PlayerAI = PlayerAI;\nclass MonsterAI extends AI {\n    constructor() {\n        super();\n        this.TRACKING_TURNS = 3;\n        this.moveCount = 0;\n    }\n    update(owner) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const player = _1.game.player;\n            if ((owner.destructible && owner.destructible.isDead()) || !player)\n                return;\n            if ((_b = (_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.fov) === null || _b === void 0 ? void 0 : _b.isInFov(owner.x, owner.y)) {\n                this.moveCount = this.TRACKING_TURNS;\n            }\n            else {\n                this.moveCount--;\n            }\n            if (this.moveCount > 0) {\n                this.moveOrAttack(owner, player.x, player.y);\n            }\n        });\n    }\n    moveOrAttack(owner, targetX, targetY) {\n        var _a, _b, _c, _d;\n        let dx = targetX - owner.x;\n        let dy = targetY - owner.y;\n        const stepdx = dx > 0 ? 1 : -1;\n        const stepdy = dy > 0 ? 1 : -1;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        if (distance >= 2) {\n            dx = Math.round(dx / distance);\n            dy = Math.round(dy / distance);\n            if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk(owner.x + dx, owner.y + dy)) {\n                owner.x += (0, utils_1.float2int)(dx);\n                owner.y += (0, utils_1.float2int)(dy);\n            }\n            else if ((_b = _1.game.map) === null || _b === void 0 ? void 0 : _b.canWalk(owner.x + stepdx, owner.y)) {\n                owner.x += (0, utils_1.float2int)(stepdx);\n            }\n            else if ((_c = _1.game.map) === null || _c === void 0 ? void 0 : _c.canWalk(owner.x, owner.y + stepdy)) {\n                owner.y += (0, utils_1.float2int)(stepdy);\n            }\n        }\n        else {\n            (_d = owner === null || owner === void 0 ? void 0 : owner.attacker) === null || _d === void 0 ? void 0 : _d.attack(owner, (0, utils_1.ensure)(_1.game.player));\n        }\n    }\n}\nexports.MonsterAI = MonsterAI;\nclass ConfusedAI extends AI {\n    constructor(nbTurns, oldAi) {\n        super();\n        this.nbTurns = nbTurns;\n        this.oldAi = oldAi;\n    }\n    update(owner) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const dx = exports.random.getInt(-1, 1);\n            const dy = exports.random.getInt(-1, 1);\n            if (dx !== 0 || dy !== 0) {\n                const destx = owner.x + dx;\n                const desty = owner.y + dy;\n                if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk(destx, desty)) {\n                    owner.x = destx;\n                    owner.y = desty;\n                }\n                else {\n                    const actor = _1.game.getActor(destx, desty);\n                    if (actor) {\n                        (_b = owner === null || owner === void 0 ? void 0 : owner.attacker) === null || _b === void 0 ? void 0 : _b.attack(owner, actor);\n                    }\n                }\n            }\n            this.nbTurns--;\n            if (this.nbTurns <= 0) {\n                owner.ai = this.oldAi;\n            }\n        });\n    }\n}\nexports.ConfusedAI = ConfusedAI;\nclass TemporaryAI extends AI {\n    constructor(nbTurns) {\n        super();\n        this.nbTurns = nbTurns;\n    }\n    update(owner) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.nbTurns--;\n            if (this.nbTurns === 0) {\n                owner.ai = this.oldAi;\n            }\n        });\n    }\n    applyTo(actor) {\n        this.oldAi = actor.ai;\n        actor.ai = this;\n    }\n}\nexports.TemporaryAI = TemporaryAI;\nclass ConfusedMonsterAi extends TemporaryAI {\n    constructor(nbTurns) {\n        super(nbTurns);\n    }\n    update(owner) {\n        const _super = Object.create(null, {\n            update: { get: () => super.update }\n        });\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const dx = exports.random.getInt(-1, 1);\n            const dy = exports.random.getInt(-1, 1);\n            if (dx != 0 || dy != 0) {\n                const destx = owner.x + dx;\n                const desty = owner.y + dy;\n                if ((_a = _1.game.map) === null || _a === void 0 ? void 0 : _a.canWalk(destx, desty)) {\n                    owner.x = destx;\n                    owner.y = desty;\n                }\n                else {\n                    const actor = _1.game.getActor(destx, desty);\n                    if (actor) {\n                        (_b = owner === null || owner === void 0 ? void 0 : owner.attacker) === null || _b === void 0 ? void 0 : _b.attack(owner, actor);\n                    }\n                }\n            }\n            _super.update.call(this, owner);\n        });\n    }\n}\nexports.ConfusedMonsterAi = ConfusedMonsterAi;\n\n\n//# sourceURL=webpack://slanrl/./src/units/ai.ts?");

/***/ }),

/***/ "./src/units/destructible.ts":
/*!***********************************!*\
  !*** ./src/units/destructible.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PlayerDestructible = exports.MonsterDestructible = void 0;\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst colors_1 = __webpack_require__(/*! ../utils/colors */ \"./src/utils/colors.ts\");\nconst utils_1 = __webpack_require__(/*! ../utils/utils */ \"./src/utils/utils.ts\");\nclass Destructible {\n    constructor(maxHP, defense, corpseName, type, xp) {\n        this.maxHP = maxHP;\n        this.hp = this.maxHP;\n        this.defense = defense;\n        this.corpseName = corpseName;\n        this.type = type;\n        this.xp = xp;\n    }\n    isDead() {\n        return this.hp <= 0;\n    }\n    heal(amount) {\n        this.hp += amount;\n        if (this.hp > this.maxHP) {\n            amount -= this.hp - this.maxHP;\n            this.hp = this.maxHP;\n        }\n        return amount;\n    }\n    takeDamage(owner, damage) {\n        this.hp -= damage;\n        if (this.hp <= 0) {\n            this.die(owner);\n        }\n        return damage;\n    }\n    die(owner) {\n        //owner.ch = owner;\n        owner.color = colors_1.Colors.DEAD_BODY;\n        owner.name = this.corpseName;\n        owner.blocks = false;\n        _1.game.sendToBack(owner);\n    }\n}\nexports[\"default\"] = Destructible;\nclass MonsterDestructible extends Destructible {\n    constructor(maxHP, defense, corpseName, xp) {\n        super(maxHP, defense, corpseName, \"monster\", xp);\n        this.xp = xp;\n    }\n    die(owner) {\n        var _a;\n        _1.game.log.add(`${owner.name} is dead. You gain ${this.xp} xp`);\n        (0, utils_1.ensure)((_a = _1.game.player) === null || _a === void 0 ? void 0 : _a.destructible).xp += this.xp;\n        super.die(owner);\n    }\n}\nexports.MonsterDestructible = MonsterDestructible;\nclass PlayerDestructible extends Destructible {\n    constructor(maxHP, defense, corpseName) {\n        super(maxHP, defense, corpseName, \"player\", 0);\n    }\n    die(owner) {\n        _1.game.log.add(\"You died\", colors_1.Colors.DEFEAT);\n        super.die(owner);\n        _1.game.gameStatus = _1.GameStatus.DEFEAT;\n    }\n}\nexports.PlayerDestructible = PlayerDestructible;\n\n\n//# sourceURL=webpack://slanrl/./src/units/destructible.ts?");

/***/ }),

/***/ "./src/utils/colors.ts":
/*!*****************************!*\
  !*** ./src/utils/colors.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Colors = void 0;\nexports.Colors = {\n    //map\n    BACKGROUND: \"#1f273c\",\n    WALL: \"#8cb2c6\",\n    WALL_DARK: \"#495c67\",\n    DOOR: \"#ddc275\",\n    //pickups\n    HEALTHPOTION: \"#FF00FF\",\n    NUTELLABUN: \"#ddc275\",\n    SCROLL_OF_LIGHTING: \"#00FFFF\",\n    SCROLL_OF_FIREBALL: \"#FFAA00\",\n    SCROLL_OF_CONFUSION: \"#FFFFAA\",\n    SCROLL_OF_MAP: \"#AAAA22\",\n    ARMOR_ITEM: \"#99AACC\",\n    WEAPON_ITEM: \"#33FF33\",\n    //ui\n    LEVEL_UP: \"#FFFF00\",\n    HEALED: \"#8F8\",\n    MENU_CURSOR: \"#AAA\",\n    GAME_SAVED: \"#0FA\",\n    PICKED_UP: \"#AAA\",\n    INVENTORY_FULL: \"#F00\",\n    MENU_BORDER: \"#AAA\",\n    ALLOWED: \"#FFF\",\n    DISALLOWED: \"#F88\",\n    HP_10_PERCENT: \"#F44\",\n    HP_25_PERCENT: \"#F88\",\n    HP_50_PERCENT: \"#FAA\",\n    HP_95_PERENT: \"#AAA\",\n    HP_MAX: \"#AFA\",\n    //actors\n    HERO: \"#FFF\",\n    STAIRS: \"#FFF\",\n    //log\n    PLAYER_ATTACK: \"#DDD\",\n    ENEMY_ATTACK: \"#AAA\",\n    DEAD_BODY: \"#A00\",\n    DEFAULT_TEXT: \"#AAA\",\n    HILIGHT_TEXT: \"#FFF\",\n    DEFEAT: \"#A00\",\n};\n\n\n//# sourceURL=webpack://slanrl/./src/utils/colors.ts?");

/***/ }),

/***/ "./src/utils/log.ts":
/*!**************************!*\
  !*** ./src/utils/log.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst _1 = __webpack_require__(/*! ../. */ \"./src/index.ts\");\nconst colors_1 = __webpack_require__(/*! ./colors */ \"./src/utils/colors.ts\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./src/utils/utils.ts\");\nclass LogText {\n    constructor(text, color) {\n        this.text = text;\n        this.color = color;\n    }\n}\nclass Log {\n    constructor() {\n        this.SIZE_OF_LOG = 100;\n        this.texts = [];\n    }\n    render() {\n        let a = 0;\n        let l = this.texts.length;\n        if (l > 10)\n            l = 10;\n        for (let i = this.texts.length - 16; i < this.texts.length; i++) {\n            if (i >= 0) {\n                _1.game.drawText(this.texts[i].text, 1, _1.game.height + 3 + a, (0, utils_1.dimmerColor)(this.texts[i].color, (20 - l) * 0.05));\n                a++;\n                l--;\n            }\n        }\n    }\n    add(text, color = colors_1.Colors.DEFAULT_TEXT) {\n        this.texts.push(new LogText(text, color));\n        if (this.texts.length > this.SIZE_OF_LOG) {\n            this.texts.splice(0, 1);\n        }\n    }\n}\nexports[\"default\"] = Log;\n\n\n//# sourceURL=webpack://slanrl/./src/utils/log.ts?");

/***/ }),

/***/ "./src/utils/menu.ts":
/*!***************************!*\
  !*** ./src/utils/menu.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Menu = exports.MenuItemCode = exports.MenuItem = void 0;\nclass MenuItem {\n    constructor() {\n        this.code = 0;\n        this.label = \"\";\n    }\n}\nexports.MenuItem = MenuItem;\nvar MenuItemCode;\n(function (MenuItemCode) {\n    MenuItemCode[MenuItemCode[\"NONE\"] = 0] = \"NONE\";\n    MenuItemCode[MenuItemCode[\"NEW_GAME\"] = 1] = \"NEW_GAME\";\n    MenuItemCode[MenuItemCode[\"CONTINUE\"] = 2] = \"CONTINUE\";\n    MenuItemCode[MenuItemCode[\"EXIT\"] = 3] = \"EXIT\";\n    MenuItemCode[MenuItemCode[\"CONSTITUTION\"] = 4] = \"CONSTITUTION\";\n    MenuItemCode[MenuItemCode[\"STRENGTH\"] = 5] = \"STRENGTH\";\n    MenuItemCode[MenuItemCode[\"AGILITY\"] = 6] = \"AGILITY\";\n})(MenuItemCode = exports.MenuItemCode || (exports.MenuItemCode = {}));\nclass Menu {\n    constructor() {\n        this.items = [];\n    }\n    clear() {\n        if (this.items && this.items.length > 0)\n            this.items = [];\n    }\n    addItem(code, label) {\n        const item = new MenuItem();\n        item.code = code;\n        item.label = label;\n        this.items.push(item);\n    }\n}\nexports.Menu = Menu;\n\n\n//# sourceURL=webpack://slanrl/./src/utils/menu.ts?");

/***/ }),

/***/ "./src/utils/random.ts":
/*!*****************************!*\
  !*** ./src/utils/random.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet _seed = 0;\nclass Randomizer {\n    constructor() {\n        this.rnd = 0;\n    }\n    setSeed(seed) {\n        _seed = seed;\n    }\n    calc() {\n        _seed = (_seed * 9301 + 49297) % 233280;\n        this.rnd = _seed / 233280.0;\n    }\n    getInt(min, max) {\n        max = max || 1;\n        min = min || 0;\n        this.calc();\n        return Math.floor(min + this.rnd * (max - min));\n    }\n    dice(dices, eyes, bonus) {\n        let v = 0;\n        eyes++;\n        for (let i = 0; i < dices; i++) {\n            v += Number(this.getInt(1, eyes));\n        }\n        v += +bonus;\n        if (v < dices)\n            v = dices;\n        return v;\n    }\n}\nexports[\"default\"] = Randomizer;\n\n\n//# sourceURL=webpack://slanrl/./src/utils/random.ts?");

/***/ }),

/***/ "./src/utils/rectangle.ts":
/*!********************************!*\
  !*** ./src/utils/rectangle.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Rectangle {\n    constructor(x, y, w, h) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n        this.h = h;\n    }\n    GetHalfDimensionX() {\n        return this.w / 2;\n    }\n    GetHalfDimensionY() {\n        return this.h / 2;\n    }\n    GetCenterX() {\n        return this.x + this.GetHalfDimensionX();\n    }\n    GetCenterY() {\n        return this.y + this.GetHalfDimensionY();\n    }\n}\nexports[\"default\"] = Rectangle;\n\n\n//# sourceURL=webpack://slanrl/./src/utils/rectangle.ts?");

/***/ }),

/***/ "./src/utils/utils.ts":
/*!****************************!*\
  !*** ./src/utils/utils.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dimmerColor = exports.rgbToHex = exports.hexToRGB = exports.ensure = exports.float2int = exports.debugInit = exports.printVersionContainer = exports.populateVersion = exports.paddedLogObject = void 0;\nconst paddedLogObject = (object) => {\n    const maxKeyLength = Object.keys(object).reduce((previousValue, currentValue) => currentValue.length + 3 > previousValue\n        ? currentValue.length + 3\n        : previousValue, 0);\n    console.log(Object.keys(object)\n        .map(key => `${key.padEnd(maxKeyLength, \" \")}: ${object[key]}`)\n        .join(\"\\n\"));\n};\nexports.paddedLogObject = paddedLogObject;\nconst populateVersion = () => `Commit ID: <span>${\"a22f76a\"}</span> | Version: <span>${\"v0.0.1.12a\"}</span>`;\nexports.populateVersion = populateVersion;\nconst printVersionContainer = () => {\n    (0, exports.ensure)(document.querySelector(\"#version\")).innerHTML = (0, exports.populateVersion)();\n};\nexports.printVersionContainer = printVersionContainer;\nconst debugInit = () => {\n    // Populates the content for \"version\" div in the bottom right corner\n    (0, exports.printVersionContainer)();\n    // Console logs a padded object\n    (0, exports.paddedLogObject)({\n        BUILD_DATE: \"2021-10-31\",\n        BUILD_TIME: \"22:07:44\",\n        BUILD_DATETIME: \"2021-10-31T22:07:44.155Z\",\n        COMMIT_HASH: \"a22f76a\",\n        VERSION: \"v0.0.1.12a\",\n    });\n};\nexports.debugInit = debugInit;\nconst float2int = (value) => {\n    return value >> 0;\n};\nexports.float2int = float2int;\nconst ensure = (argument, message = \"This value was promised to be there.\") => {\n    if (argument === undefined || argument === null) {\n        throw new TypeError(message);\n    }\n    return argument;\n};\nexports.ensure = ensure;\nconst hexToRGB = (h) => {\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    // 3 digits\n    if (h.length == 4) {\n        r = parseInt(\"0x\" + h[1] + h[1], 16);\n        g = parseInt(\"0x\" + h[2] + h[2], 16);\n        b = parseInt(\"0x\" + h[3] + h[3], 16);\n        // 6 digits\n    }\n    else if (h.length == 7) {\n        r = parseInt(\"0x\" + h[1] + h[2], 16);\n        g = parseInt(\"0x\" + h[3] + h[4], 16);\n        b = parseInt(\"0x\" + h[5] + h[6], 16);\n    }\n    return [r, g, b];\n};\nexports.hexToRGB = hexToRGB;\nconst rgbToHex = (r, g, b) => {\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n};\nexports.rgbToHex = rgbToHex;\nconst dimmerColor = (color, dim) => {\n    let [r, g, b] = (0, exports.hexToRGB)(color);\n    r *= dim;\n    g *= dim;\n    b *= dim;\n    if (r < 0)\n        r = 0;\n    if (g < 0)\n        g = 0;\n    if (b < 0)\n        b = 0;\n    if (r > 255)\n        r = 255;\n    if (g > 255)\n        g = 255;\n    if (b > 255)\n        b = 255;\n    r = (0, exports.float2int)(r);\n    g = (0, exports.float2int)(g);\n    b = (0, exports.float2int)(b);\n    return (0, exports.rgbToHex)(r, g, b);\n};\nexports.dimmerColor = dimmerColor;\n\n\n//# sourceURL=webpack://slanrl/./src/utils/utils.ts?");

/***/ }),

/***/ "./src/data/armors.json":
/*!******************************!*\
  !*** ./src/data/armors.json ***!
  \******************************/
/***/ ((module) => {

eval("module.exports = JSON.parse('[{\"name\":\"leather armor\",\"ac\":11,\"armorType\":\"light\",\"weight\":10},{\"name\":\"studded leather\",\"ac\":12,\"armorType\":\"light\",\"weight\":13},{\"name\":\"hide\",\"ac\":12,\"armorType\":\"medium\",\"weight\":12},{\"name\":\"chain shirt\",\"ac\":13,\"armorType\":\"medium\",\"weight\":20},{\"name\":\"scale mail\",\"ac\":14,\"armorType\":\"medium\",\"weight\":45},{\"name\":\"breastplate\",\"ac\":14,\"armorType\":\"medium\",\"weight\":20},{\"name\":\"half plate\",\"ac\":15,\"armorType\":\"medium\",\"weight\":40},{\"name\":\"ringmail\",\"ac\":14,\"armorType\":\"heavy\",\"weight\":40},{\"name\":\"chain mail\",\"ac\":16,\"armorType\":\"heavy\",\"weight\":55},{\"name\":\"splint\",\"ac\":17,\"armorType\":\"heavy\",\"weight\":60},{\"name\":\"plate\",\"ac\":18,\"armorType\":\"heavy\",\"weight\":65},{\"name\":\"shield\",\"ac\":2,\"armorType\":\"shield\",\"weight\":6}]');\n\n//# sourceURL=webpack://slanrl/./src/data/armors.json?");

/***/ }),

/***/ "./src/data/items.json":
/*!*****************************!*\
  !*** ./src/data/items.json ***!
  \*****************************/
/***/ ((module) => {

eval("module.exports = JSON.parse('[{\"name\":\"health potion\",\"message\":\"gulp gulp gulp...\",\"ch\":\"!\",\"color\":\"#FF00FF\",\"weight\":0.1,\"selector\":{\"type\":\"none\",\"range\":0},\"effect\":{\"type\":\"health\",\"amount\":4}},{\"name\":\"nutella bun\",\"message\":\"omnomnom...\",\"ch\":\"@\",\"color\":\"#FF00FF\",\"weight\":0.1,\"selector\":{\"type\":\"none\",\"range\":0},\"effect\":{\"type\":\"health\",\"amount\":30}},{\"name\":\"scroll of fireball\",\"message\":\"Everything burns\",\"ch\":\"#\",\"color\":\"#FFAA00\",\"weight\":0.05,\"selector\":{\"type\":\"selected range\",\"range\":3},\"effect\":{\"type\":\"health\",\"amount\":-12}},{\"name\":\"scroll of confusion\",\"message\":\"confused af\",\"ch\":\"#\",\"color\":\"#FFCCAA\",\"weight\":0.05,\"selector\":{\"type\":\"selected monster\",\"range\":5},\"effect\":{\"type\":\"change ai\",\"amount\":10}},{\"name\":\"scroll of map\",\"message\":\"All is clear!\",\"ch\":\"#\",\"color\":\"#FFAA99\",\"weight\":0.05,\"selector\":{\"type\":\"none\",\"range\":0},\"effect\":{\"type\":\"map clear\",\"amount\":0}},{\"name\":\"scroll of lighting bolt\",\"message\":\"A lighting bolt strikes!\",\"ch\":\"#\",\"color\":\"#00CCFF\",\"weight\":0.05,\"selector\":{\"type\":\"closest monster\",\"range\":5},\"effect\":{\"type\":\"health\",\"amount\":-20}}]');\n\n//# sourceURL=webpack://slanrl/./src/data/items.json?");

/***/ }),

/***/ "./src/data/monsters.json":
/*!********************************!*\
  !*** ./src/data/monsters.json ***!
  \********************************/
/***/ ((module) => {

eval("module.exports = JSON.parse('[{\"name\":\"bat\",\"size:\":\"tiny\",\"type\":\"beast\",\"ch\":\"b\",\"color\":\"#888\",\"hp\":1,\"ac\":12,\"xp\":5,\"abilities\":{\"str\":2,\"dex\":15,\"con\":8,\"int\":2,\"wis\":12},\"attacks\":[{\"name\":\"bite\",\"damage\":\"1d1\",\"damageType\":\"piercing\"}]},{\"name\":\"jackal\",\"size:\":\"small\",\"type\":\"beast\",\"ch\":\"j\",\"color\":\"#888\",\"hp\":3,\"ac\":12,\"xp\":10,\"abilities\":{\"str\":8,\"dex\":15,\"con\":11,\"int\":3,\"wis\":12},\"attacks\":[{\"name\":\"bite\",\"damage\":\"1d4\",\"damageType\":\"piercing\"}]},{\"name\":\"lizard\",\"size:\":\"tiny\",\"type\":\"beast\",\"ch\":\"l\",\"color\":\"#00AA33\",\"hp\":2,\"ac\":10,\"xp\":10,\"abilities\":{\"str\":2,\"dex\":11,\"con\":10,\"int\":1,\"wis\":8},\"attacks\":[{\"name\":\"bite\",\"damage\":\"1d1\",\"damageType\":\"piercing\"}]},{\"name\":\"kobold\",\"size:\":\"small\",\"type\":\"humanoid\",\"ch\":\"k\",\"color\":\"#A88\",\"hp\":5,\"ac\":12,\"xp\":25,\"abilities\":{\"str\":7,\"dex\":15,\"con\":9,\"int\":8,\"wis\":7},\"attacks\":[{\"name\":\"dagger\",\"damage\":\"1d4\",\"damageType\":\"piercing\"},{\"name\":\"sling\",\"damage\":\"1d4\",\"damageType\":\"bludgeoning\"}]},{\"name\":\"rat\",\"size:\":\"tiny\",\"type\":\"beast\",\"ch\":\"r\",\"color\":\"#888\",\"hp\":1,\"ac\":10,\"xp\":5,\"abilities\":{\"str\":2,\"dex\":11,\"con\":9,\"int\":2,\"wis\":10},\"attacks\":[{\"name\":\"bite\",\"damage\":\"1d1\",\"damageType\":\"piercing\"}]},{\"name\":\"giant rat\",\"size:\":\"small\",\"type\":\"beast\",\"ch\":\"R\",\"color\":\"#888\",\"hp\":7,\"ac\":12,\"xp\":25,\"abilities\":{\"str\":7,\"dex\":15,\"con\":11,\"int\":2,\"wis\":10},\"attacks\":[{\"name\":\"bite\",\"damage\":\"1d4\",\"damageType\":\"piercing\"}]},{\"name\":\"ghoul\",\"size\":\"medium\",\"type\":\"undead\",\"ch\":\"G\",\"color\":\"#00AA99\",\"hp\":22,\"ac\":12,\"xp\":200,\"abilities\":{\"str\":13,\"dex\":15,\"con\":10,\"int\":7,\"wis\":10},\"attacks\":[{\"name\":\"bite\",\"damage\":\"2d6\",\"damageType\":\"piercing\"},{\"name\":\"claws\",\"damage\":\"2d4\",\"damageType\":\"slashing\"}]},{\"name\":\"orc\",\"size\":\"medium\",\"type\":\"humanoid\",\"ch\":\"o\",\"color\":\"#00AA00\",\"hp\":15,\"ac\":13,\"xp\":100,\"abilities\":{\"str\":16,\"dex\":12,\"con\":16,\"int\":7,\"wis\":11},\"attacks\":[{\"name\":\"greataxe\",\"damage\":\"1d12\",\"damageType\":\"slashing\"},{\"name\":\"javelin\",\"damage\":\"1d6\",\"damageType\":\"piercing\"}]},{\"name\":\"troll\",\"size\":\"large\",\"type\":\"giant\",\"ch\":\"t\",\"color\":\"#008800\",\"hp\":84,\"ac\":15,\"xp\":1800,\"abilities\":{\"str\":18,\"dex\":13,\"con\":20,\"int\":7,\"wis\":9},\"attacks\":[{\"name\":\"bite\",\"damage\":\"1d16\",\"damageType\":\"piercing\"},{\"name\":\"claw\",\"damage\":\"2d6\",\"damageType\":\"slashing\"}]}]');\n\n//# sourceURL=webpack://slanrl/./src/data/monsters.json?");

/***/ }),

/***/ "./src/data/weapons.json":
/*!*******************************!*\
  !*** ./src/data/weapons.json ***!
  \*******************************/
/***/ ((module) => {

eval("module.exports = JSON.parse('[{\"name\":\"club\",\"damage\":\"1d4\",\"damageType\":\"bludgeoning\",\"weight\":2,\"wearableType\":\"one-handed\"},{\"name\":\"dagger\",\"damage\":\"1d4\",\"damageType\":\"piercing\",\"weight\":1,\"wearableType\":\"one-handed\"},{\"name\":\"greatclub\",\"damage\":\"1d4\",\"damageType\":\"bludgeoning\",\"weight\":10,\"wearableType\":\"two-handed\"},{\"name\":\"handaxe\",\"damage\":\"1d6\",\"damageType\":\"slashing\",\"weight\":2,\"wearableType\":\"one-handed\"},{\"name\":\"javelin\",\"damage\":\"1d6\",\"damageType\":\"piercing\",\"weight\":2,\"wearableType\":\"one-handed\"},{\"name\":\"light hammer\",\"damage\":\"1d4\",\"damageType\":\"bludgeoning\",\"weight\":2,\"wearableType\":\"one-handed\"},{\"name\":\"mace\",\"damage\":\"1d6\",\"damageType\":\"bludgeoning\",\"weight\":4,\"wearableType\":\"one-handed\"},{\"name\":\"quarterstaff\",\"damage\":\"1d6\",\"damageType\":\"bludgeoning\",\"weight\":4,\"wearableType\":\"one-handed\"},{\"name\":\"spear\",\"damage\":\"1d6\",\"damageType\":\"piercing\",\"weight\":3,\"wearableType\":\"one-handed\"}]');\n\n//# sourceURL=webpack://slanrl/./src/data/weapons.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;